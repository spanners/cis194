<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="generator" content="MediaWiki 1.19.5-1+deb7u1" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/haskellwiki/opensearch_desc.php" title="HaskellWiki (en)" />
<link rel="EditURI" type="application/rsd+xml" href="http://www.haskell.org/haskellwiki/api.php?action=rsd" />
<link rel="copyright" href="/haskellwiki/HaskellWiki:Copyrights" />
<link rel="alternate" type="application/atom+xml" title="HaskellWiki Atom feed" href="/haskellwiki/index.php?title=Special:RecentChanges&amp;feed=atom" />		<title>Typeclassopedia - HaskellWiki</title>
		<style type="text/css" media="screen, projection">/*<![CDATA[*/
			@import "/wikistatic/skins//common/shared.css?303";
			@import "/wikistatic/skins//hawiki/main.css?303";
		/*]]>*/</style>
		<link rel="stylesheet" type="text/css" media="print" href="/wikistatic/skins//common/commonPrint.css?303" />
		<!--[if lt IE 5.5000]><style type="text/css">@import "/wikistatic/skins//hawiki/IE50Fixes.css?303";</style><![endif]-->
		<!--[if IE 5.5000]><style type="text/css">@import "/wikistatic/skins//hawiki/IE55Fixes.css?303";</style><![endif]-->
		<!--[if IE 6]><style type="text/css">@import "/wikistatic/skins//hawiki/IE60Fixes.css?303";</style><![endif]-->
		<!--[if IE 7]><style type="text/css">@import "/wikistatic/skins//hawiki/IE70Fixes.css?303";</style><![endif]-->
		<!--[if lte IE 7]><script type="text/javascript" src="/wikistatic/skins//hawiki/IEFixes.js?303"></script>
		<meta http-equiv="imagetoolbar" content="no" /><![endif]-->
                                                <script type="text/javascript">
                        var isMSIE55 = (window.showModalDialog && window.clipboardData && window.createPopup); /*alert("test: " + isMSIE55);*/</script>

		<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Typeclassopedia","wgTitle":"Typeclassopedia","wgCurRevisionId":58733,"wgArticleId":5000,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Applicative Functor","Arrow","Functor","Monad","Standard classes","Standard libraries","Standard packages","Standard types"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgRelevantPageName":"Typeclassopedia","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script>
		<script type="text/javascript" src="/wikistatic/skins//common/wikibits.js?303"><!-- wikibits js --></script>
		<!-- Head Scripts -->
<script src="http://www.haskell.org/haskellwiki/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=hawiki&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Typeclassopedia","wgTitle":"Typeclassopedia","wgCurRevisionId":58733,"wgArticleId":5000,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Applicative Functor","Arrow","Functor","Monad","Standard classes","Standard libraries","Standard packages","Standard types"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgRelevantPageName":"Typeclassopedia","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":1,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"hawiki","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;},{},{});mw.loader.implement("user.tokens",function($){mw.user.tokens.set({"editToken":"+\\","watchToken":false});;},{},{});

/* cache key: wikidb:resourceloader:filter:minify-js:7:befcdb5e3b24ff89f900613de9ed4ea3 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script><style type="text/css">/*<![CDATA[*/
.source-haskell {line-height: normal;}
.source-haskell li, .source-haskell pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for haskell
 * CSS class: source-haskell, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.haskell.source-haskell .de1, .haskell.source-haskell .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.haskell.source-haskell  {font-family:monospace;}
.haskell.source-haskell .imp {font-weight: bold; color: red;}
.haskell.source-haskell li, .haskell.source-haskell .li1 {font-weight: normal; vertical-align:top;}
.haskell.source-haskell .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.haskell.source-haskell .li2 {font-weight: bold; vertical-align:top;}
.haskell.source-haskell .kw1 {color: #06c; font-weight: bold;}
.haskell.source-haskell .kw2 {color: #06c; font-weight: bold;}
.haskell.source-haskell .kw3 {font-weight: bold;}
.haskell.source-haskell .kw4 {color: #cccc00; font-weight: bold;}
.haskell.source-haskell .kw5 {color: maroon;}
.haskell.source-haskell .co1 {color: #5d478b; font-style: italic;}
.haskell.source-haskell .co2 {color: #339933; font-weight: bold;}
.haskell.source-haskell .coMULTI {color: #5d478b; font-style: italic;}
.haskell.source-haskell .es0 {background-color: #3cb371; font-weight: bold;}
.haskell.source-haskell .br0 {color: green;}
.haskell.source-haskell .sy0 {color: #339933; font-weight: bold;}
.haskell.source-haskell .st0 {background-color: #3cb371;}
.haskell.source-haskell .nu0 {color: red;}
.haskell.source-haskell .me1 {color: #060;}
.haskell.source-haskell .ln-xtra, .haskell.source-haskell li.ln-xtra, .haskell.source-haskell div.ln-xtra {background-color: #ffc;}
.haskell.source-haskell span.xtra { display:block; }

/*]]>*/
</style>	</head>
<body class="mediawiki ltr ns-0 ns-subject page-Typeclassopedia skin-hawiki">
   <div id="topbar" class="noprint">
	<div class="portlet noprint" id="p-personal">
		<h5>Personal tools</h5>
		<div class="pBody">
			<ul><li><a class="homebutton" href="/haskellwiki/Haskell">Home</a></li>
				<li id="pt-login"><a href="/haskellwiki/index.php?title=Special:UserLogin&amp;returnto=Typeclassopedia">Log in</a></li>
			</ul>
		</div>
	</div>
        	  <div id="p-search">
	    <div id="searchBody" class="pBody">
	       <form action="/haskellwiki/index.php" id="searchform"><div>
	          <input type='hidden' name="title" value="Special:Search"/>
	          <input id="searchInput" name="search" type="text" value="" />
				<input type='submit' name="go" class="searchButton" id="searchGoButton"	value="Go" />&nbsp;
				<input type='submit' name="fulltext" class="searchButton" id="mw-searchButton" value="Search" />

	         </div></form>
	    </div>
	  </div>
   </div>
	<div id="globalWrapper">
	<div class="portlet" id="p-logo">
		<a style="background-image: url(/wikistatic/haskellwiki_logo.png);" href="/haskellwiki/Haskell"></a>
	</div>
	<div id="column-content">
        <div id="notice-area" class="noprint">
        <!-- ?php $this->data['sitenotice'] = 'This is a test instance.  Do not edit, your changes will be lost.'; ? -->
			        </div>
        <div id="content-wrapper">
	<div id="p-cactions" class="portlet noprint">
		<h5>Views</h5>
		<div class="pBody">
			<ul>
	
				 <li id="ca-nstab-main" class="selected"><a href="/haskellwiki/Typeclassopedia">Page</a></li>
				 <li id="ca-talk"><a href="/haskellwiki/Talk:Typeclassopedia">Discussion</a></li>
				 <li id="ca-viewsource"><a href="/haskellwiki/index.php?title=Typeclassopedia&amp;action=edit">View source</a></li>
				 <li id="ca-history"><a href="/haskellwiki/index.php?title=Typeclassopedia&amp;action=history">History</a></li>			</ul>
		</div>
	</div>
                        <div id="content">
		<a name="top" id="top"></a>
                        <h1 id="firstHeading" class="firstHeading">Typeclassopedia</h1>
		<div id="bodyContent">
			<h3 id="siteSub">From HaskellWiki</h3>
			<div id="contentSub"></div>
			<div id="jump-to-nav">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>			<!-- start content -->
			<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p><i>By <a href="/haskellwiki/User:Byorgey" title="User:Byorgey">Brent Yorgey</a>, byorgey@cis.upenn.edu</i>
</p><p><i>Originally published 12 March 2009 in <a rel="nofollow" class="external text" href="http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf">issue 13</a> of <a rel="nofollow" class="external text" href="http://themonadreader.wordpress.com/">the Monad.Reader</a>. Ported to the Haskell wiki in November 2011 by <a href="/haskellwiki/User:Geheimdienst" title="User:Geheimdienst">Geheimdienst</a>.</i>
</p><p><i>This is now the official version of the Typeclassopedia and supersedes the version published in the Monad.Reader.  Please help update and extend it by editing it yourself or by leaving comments, suggestions, and questions on the <a href="/haskellwiki/Talk:Typeclassopedia" title="Talk:Typeclassopedia">talk page</a>.</i>
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Abstract"><span class="tocnumber">1</span> <span class="toctext">Abstract</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Introduction"><span class="tocnumber">2</span> <span class="toctext">Introduction</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Functor"><span class="tocnumber">3</span> <span class="toctext">Functor</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Definition"><span class="tocnumber">3.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Instances"><span class="tocnumber">3.2</span> <span class="toctext">Instances</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Laws"><span class="tocnumber">3.3</span> <span class="toctext">Laws</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Intuition"><span class="tocnumber">3.4</span> <span class="toctext">Intuition</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Further_reading"><span class="tocnumber">3.5</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Applicative"><span class="tocnumber">4</span> <span class="toctext">Applicative</span></a>
<ul>
<li class="toclevel-2 tocsection-10"><a href="#Definition_2"><span class="tocnumber">4.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Laws_2"><span class="tocnumber">4.2</span> <span class="toctext">Laws</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Instances_2"><span class="tocnumber">4.3</span> <span class="toctext">Instances</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Intuition_2"><span class="tocnumber">4.4</span> <span class="toctext">Intuition</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Alternative_formulation"><span class="tocnumber">4.5</span> <span class="toctext">Alternative formulation</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Further_reading_2"><span class="tocnumber">4.6</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-16"><a href="#Monad"><span class="tocnumber">5</span> <span class="toctext">Monad</span></a>
<ul>
<li class="toclevel-2 tocsection-17"><a href="#Definition_3"><span class="tocnumber">5.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Instances_3"><span class="tocnumber">5.2</span> <span class="toctext">Instances</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Intuition_3"><span class="tocnumber">5.3</span> <span class="toctext">Intuition</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#Utility_functions"><span class="tocnumber">5.4</span> <span class="toctext">Utility functions</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#Laws_3"><span class="tocnumber">5.5</span> <span class="toctext">Laws</span></a></li>
<li class="toclevel-2 tocsection-22"><a href="#do_notation"><span class="tocnumber">5.6</span> <span class="toctext">do notation</span></a></li>
<li class="toclevel-2 tocsection-23"><a href="#Further_reading_3"><span class="tocnumber">5.7</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-24"><a href="#Monad_transformers"><span class="tocnumber">6</span> <span class="toctext">Monad transformers</span></a>
<ul>
<li class="toclevel-2 tocsection-25"><a href="#Standard_monad_transformers"><span class="tocnumber">6.1</span> <span class="toctext">Standard monad transformers</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#Definition_and_laws"><span class="tocnumber">6.2</span> <span class="toctext">Definition and laws</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#Transformer_type_classes_and_.22capability.22_style"><span class="tocnumber">6.3</span> <span class="toctext">Transformer type classes and "capability" style</span></a></li>
<li class="toclevel-2 tocsection-28"><a href="#Composing_monads"><span class="tocnumber">6.4</span> <span class="toctext">Composing monads</span></a></li>
<li class="toclevel-2 tocsection-29"><a href="#Further_reading_4"><span class="tocnumber">6.5</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-30"><a href="#MonadFix"><span class="tocnumber">7</span> <span class="toctext">MonadFix</span></a>
<ul>
<li class="toclevel-2 tocsection-31"><a href="#mdo.2Fdo_rec_notation"><span class="tocnumber">7.1</span> <span class="toctext">mdo/do rec notation</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#Examples_and_intuition"><span class="tocnumber">7.2</span> <span class="toctext">Examples and intuition</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#GHC_7.6_changes"><span class="tocnumber">7.3</span> <span class="toctext">GHC 7.6 changes</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#Further_reading_5"><span class="tocnumber">7.4</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-35"><a href="#Semigroup"><span class="tocnumber">8</span> <span class="toctext">Semigroup</span></a>
<ul>
<li class="toclevel-2 tocsection-36"><a href="#Definition_4"><span class="tocnumber">8.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="#Laws_4"><span class="tocnumber">8.2</span> <span class="toctext">Laws</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-38"><a href="#Monoid"><span class="tocnumber">9</span> <span class="toctext">Monoid</span></a>
<ul>
<li class="toclevel-2 tocsection-39"><a href="#Definition_5"><span class="tocnumber">9.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-40"><a href="#Laws_5"><span class="tocnumber">9.2</span> <span class="toctext">Laws</span></a></li>
<li class="toclevel-2 tocsection-41"><a href="#Instances_4"><span class="tocnumber">9.3</span> <span class="toctext">Instances</span></a></li>
<li class="toclevel-2 tocsection-42"><a href="#Other_monoidal_classes:_Alternative.2C_MonadPlus.2C_ArrowPlus"><span class="tocnumber">9.4</span> <span class="toctext">Other monoidal classes: Alternative, MonadPlus, ArrowPlus</span></a></li>
<li class="toclevel-2 tocsection-43"><a href="#Further_reading_6"><span class="tocnumber">9.5</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-44"><a href="#Foldable"><span class="tocnumber">10</span> <span class="toctext">Foldable</span></a>
<ul>
<li class="toclevel-2 tocsection-45"><a href="#Definition_6"><span class="tocnumber">10.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-46"><a href="#Instances_and_examples"><span class="tocnumber">10.2</span> <span class="toctext">Instances and examples</span></a></li>
<li class="toclevel-2 tocsection-47"><a href="#Derived_folds"><span class="tocnumber">10.3</span> <span class="toctext">Derived folds</span></a></li>
<li class="toclevel-2 tocsection-48"><a href="#Foldable_actually_isn.27t"><span class="tocnumber">10.4</span> <span class="toctext">Foldable actually isn't</span></a></li>
<li class="toclevel-2 tocsection-49"><a href="#Further_reading_7"><span class="tocnumber">10.5</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-50"><a href="#Traversable"><span class="tocnumber">11</span> <span class="toctext">Traversable</span></a>
<ul>
<li class="toclevel-2 tocsection-51"><a href="#Definition_7"><span class="tocnumber">11.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-52"><a href="#Intuition_4"><span class="tocnumber">11.2</span> <span class="toctext">Intuition</span></a></li>
<li class="toclevel-2 tocsection-53"><a href="#Instances_and_examples_2"><span class="tocnumber">11.3</span> <span class="toctext">Instances and examples</span></a></li>
<li class="toclevel-2 tocsection-54"><a href="#Laws_6"><span class="tocnumber">11.4</span> <span class="toctext">Laws</span></a></li>
<li class="toclevel-2 tocsection-55"><a href="#Further_reading_8"><span class="tocnumber">11.5</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-56"><a href="#Category"><span class="tocnumber">12</span> <span class="toctext">Category</span></a>
<ul>
<li class="toclevel-2 tocsection-57"><a href="#Further_reading_9"><span class="tocnumber">12.1</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-58"><a href="#Arrow"><span class="tocnumber">13</span> <span class="toctext">Arrow</span></a>
<ul>
<li class="toclevel-2 tocsection-59"><a href="#Definition_8"><span class="tocnumber">13.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-60"><a href="#Intuition_5"><span class="tocnumber">13.2</span> <span class="toctext">Intuition</span></a></li>
<li class="toclevel-2 tocsection-61"><a href="#Instances_5"><span class="tocnumber">13.3</span> <span class="toctext">Instances</span></a></li>
<li class="toclevel-2 tocsection-62"><a href="#Laws_7"><span class="tocnumber">13.4</span> <span class="toctext">Laws</span></a></li>
<li class="toclevel-2 tocsection-63"><a href="#ArrowChoice"><span class="tocnumber">13.5</span> <span class="toctext">ArrowChoice</span></a></li>
<li class="toclevel-2 tocsection-64"><a href="#ArrowApply"><span class="tocnumber">13.6</span> <span class="toctext">ArrowApply</span></a></li>
<li class="toclevel-2 tocsection-65"><a href="#ArrowLoop"><span class="tocnumber">13.7</span> <span class="toctext">ArrowLoop</span></a></li>
<li class="toclevel-2 tocsection-66"><a href="#Arrow_notation"><span class="tocnumber">13.8</span> <span class="toctext">Arrow notation</span></a></li>
<li class="toclevel-2 tocsection-67"><a href="#Further_reading_10"><span class="tocnumber">13.9</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-68"><a href="#Comonad"><span class="tocnumber">14</span> <span class="toctext">Comonad</span></a>
<ul>
<li class="toclevel-2 tocsection-69"><a href="#Definition_9"><span class="tocnumber">14.1</span> <span class="toctext">Definition</span></a></li>
<li class="toclevel-2 tocsection-70"><a href="#Further_reading_11"><span class="tocnumber">14.2</span> <span class="toctext">Further reading</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-71"><a href="#Acknowledgements"><span class="tocnumber">15</span> <span class="toctext">Acknowledgements</span></a></li>
<li class="toclevel-1 tocsection-72"><a href="#About_the_author"><span class="tocnumber">16</span> <span class="toctext">About the author</span></a></li>
<li class="toclevel-1 tocsection-73"><a href="#Colophon"><span class="tocnumber">17</span> <span class="toctext">Colophon</span></a></li>
</ul>
</td></tr></table>
<h1> <span class="mw-headline" id="Abstract">1 Abstract</span></h1>
<p>The standard Haskell libraries feature a number of type classes with algebraic or category-theoretic underpinnings. Becoming a fluent Haskell hacker requires intimate familiarity with them all, yet acquiring this familiarity often involves combing through a mountain of tutorials, blog posts, mailing list archives, and IRC logs.
</p><p>The goal of this document is to serve as a starting point for the student of Haskell wishing to gain a firm grasp of its standard type classes. The essentials of each type class are introduced, with examples, commentary, and extensive references for further reading.
</p>
<h1> <span class="mw-headline" id="Introduction">2 Introduction</span></h1>
<p>Have you ever had any of the following thoughts?
</p>
<ul><li> What the heck is a monoid, and how is it different from a mon<u>a</u>d?
</li></ul>
<ul><li> I finally figured out how to use <a href="/haskellwiki/Parsec" title="Parsec">Parsec</a> with do-notation, and someone told me I should use something called <code>Applicative</code> instead. Um, what?
</li></ul>
<ul><li> Someone in the <a href="/haskellwiki/IRC_channel" title="IRC channel">#haskell</a> IRC channel used <code>(***)</code>, and when I asked Lambdabot to tell me its type, it printed out scary gobbledygook that didn’t even fit on one line! Then someone used <code>fmap fmap fmap</code> and my brain exploded.
</li></ul>
<ul><li> When I asked how to do something I thought was really complicated, people started typing things like <code>zip.ap fmap.(id &amp;&amp;&amp; wtf)</code> and the scary thing is that they worked! Anyway, I think those people must actually be robots because there’s no way anyone could come up with that in two seconds off the top of their head.
</li></ul>
<p>If you have, look no further! You, too, can write and understand concise, elegant, idiomatic Haskell code with the best of them.
</p><p>There are two keys to an expert Haskell hacker’s wisdom:
</p>
<ol><li> Understand the types.
</li><li> Gain a deep intuition for each type class and its relationship to other type classes, backed up by familiarity with many examples.
</li></ol>
<p>It’s impossible to overstate the importance of the first; the patient student of type signatures will uncover many profound secrets. Conversely, anyone ignorant of the types in their code is doomed to eternal uncertainty. “Hmm, it doesn’t compile ... maybe I’ll stick in an
<code>fmap</code> here ... nope, let’s see ... maybe I need another <code>(.)</code> somewhere? ... um ...”
</p><p>The second key—gaining deep intuition, backed by examples—is also important, but much more difficult to attain. A primary goal of this document is to set you on the road to gaining such intuition. However—
</p>
<dl><dd><i>There is no royal road to Haskell. <span title="Well, he probably would have said it if he knew Haskell." style="border-bottom:1px dotted" class="help">—Euclid</span></i>
</dd></dl>
<p>This document can only be a starting point, since good intuition comes from hard work, <a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">not from learning the right metaphor</a>. Anyone who reads and understands all of it will still have an arduous journey ahead—but sometimes a good starting point makes a big difference.
</p><p>It should be noted that this is not a Haskell tutorial; it is assumed that the reader is already familiar with the basics of Haskell, including the standard <code><a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Prelude</a></code>, the type system, data types, and type classes.
</p><p>The type classes we will be discussing and their interrelationships:
</p><p><a href="/haskellwiki/File:Typeclassopedia-diagram.png" class="image"><img alt="Typeclassopedia-diagram.png" src="/wikiupload/d/df/Typeclassopedia-diagram.png" width="759" height="260" /></a>
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ <code>Semigroup</code> can be found in the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/semigroups"><code>semigroups</code> package</a>, <code>Apply</code> in the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/semigroupoids"><code>semigroupoids</code> package</a>, and <code>Comonad</code> in the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/comonad"><code>comonad</code> package</a>.</span>
</p>
<ul><li> <span style="border-bottom: 2px solid black">Solid arrows</span> point from the general to the specific; that is, if there is an arrow from <code>Foo</code> to <code>Bar</code> it means that every <code>Bar</code> is (or should be, or can be made into) a <code>Foo</code>.
</li><li> <span style="border-bottom: 2px dotted black">Dotted arrows</span> indicate some other sort of relationship.
</li><li> <code>Monad</code> and <code>ArrowApply</code> are equivalent.
</li><li> <code>Semigroup</code>, <code>Apply</code> and <code>Comonad</code> are greyed out since they are not actually (yet?) in the standard Haskell libraries <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.
</li></ul>
<p>One more note before we begin. The original spelling of “type class” is with two words, as evidenced by, for example, the <a rel="nofollow" class="external text" href="http://www.haskell.org/onlinereport/haskell2010/">Haskell 2010 Language Report</a>, early papers on type classes like <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.103.5639">Type classes in Haskell</a> and <a rel="nofollow" class="external text" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/type-class-design-space/">Type classes: exploring the design space</a>, and <a rel="nofollow" class="external text" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.168.4008">Hudak et al.’s history of Haskell</a>.  However, as often happens with two-word phrases that see a lot of use, it has started to show up as one word (“typeclass”) or, rarely, hyphenated (“type-class”).  When wearing my prescriptivist hat, I prefer “type class”, but realize (after changing into my descriptivist hat) that there's probably not much I can do about it.
</p><p>We now begin with the simplest type class of all: <code>Functor</code>.
</p>
<h1> <span class="mw-headline" id="Functor">3 Functor</span></h1>
<p>The <code>Functor</code> class (<a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor">haddock</a>) is the most basic and ubiquitous type class in the Haskell libraries. A simple intuition is that a <code>Functor</code> represents a “container” of some sort, along with the ability to apply a function uniformly to every element in the container. For example, a list is a container of elements, and we can apply a function to every element of a list, using <code>map</code>. As another example, a binary tree is also a container of elements, and it’s not hard to come up with a way to recursively apply a function to every element in a tree.
</p><p>Another intuition is that a <code>Functor</code> represents some sort of “computational context”. This intuition is generally more useful, but is more difficult to explain, precisely because it is so general. Some examples later should help to clarify the <code>Functor</code>-as-context point of view.
</p><p>In the end, however, a <code>Functor</code> is simply what it is defined to be; doubtless there are many examples of <code>Functor</code> instances that don’t exactly fit either of the above intuitions. The wise student will focus their attention on definitions and examples, without leaning too heavily on any particular metaphor. Intuition will come, in time, on its own.
</p>
<h2> <span class="mw-headline" id="Definition">3.1 Definition</span></h2>
<p>Here is the type class declaration for <code>Functor</code>:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> <span class="kw4">Functor</span> f <span class="kw1">where</span>
  <span class="kw3">fmap</span> <span class="sy0">::</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> f a <span class="sy0">-&gt;</span> f b</pre></div></div>
<p><code>Functor</code> is exported by the <code>Prelude</code>, so no special imports are needed to use it.
</p><p>First, the <code>f a</code> and <code>f b</code> in the type signature for <code>fmap</code> tell us that <code>f</code> isn’t just a type; it is a <i>type constructor</i> which takes another type as a parameter. (A more precise way to say this is that the <i>kind</i> of <code>f</code> must be <code>* -&gt; *</code>.) For example, <code>Maybe</code> is such a type constructor: <code>Maybe</code> is not a type in and of itself, but requires another type as a parameter, like <code>Maybe Integer</code>. So it would not make sense to say <code>instance Functor Integer</code>, but it could make sense to say <code>instance Functor Maybe</code>.
</p><p>Now look at the type of <code>fmap</code>: it takes any function from <code>a</code> to <code>b</code>, and a value of type <code>f a</code>, and outputs a value of type <code>f b</code>. From the container point of view, the intention is that <code>fmap</code> applies a function to each element of a container, without altering the structure of the container. From the context point of view, the intention is that <code>fmap</code> applies a function to a value without altering its context. Let’s look at a few specific examples.
</p>
<h2> <span class="mw-headline" id="Instances">3.2 Instances</span></h2>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Recall that <code>[]</code> has two meanings in Haskell: it can either stand for the empty list, or, as here, it can represent the list type constructor (pronounced “list-of”). In other words, the type <code>[a]</code> (list-of-<code>a</code>) can also be written <code>[] a</code>.</span>
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ You might ask why we need a separate <code>map</code> function. Why not just do away with the current list-only <code>map</code> function, and rename <code>fmap</code> to <code>map</code> instead? Well, that’s a good question. The usual argument is that someone just learning Haskell, when using <code>map</code> incorrectly, would much rather see an error about lists than about <code>Functor</code>s.</span>
</p><p>As noted before, the list constructor <code>[]</code> is a functor <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>; we can use the standard list function <code>map</code> to apply a function to each element of a list <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>. The <code>Maybe</code> type constructor is also a functor, representing a container which might hold a single element. The function <code>fmap g</code> has no effect on <code>Nothing</code> (there are no elements to which <code>g</code> can be applied), and simply applies <code>g</code> to the single element inside a <code>Just</code>. Alternatively, under the context interpretation, the list functor represents a context of nondeterministic choice; that is, a list can be thought of as representing a single value which is nondeterministically chosen from among several possibilities (the elements of the list). Likewise, the <code>Maybe</code> functor represents a context with possible failure. These instances are:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">instance</span> <span class="kw4">Functor</span> <span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="kw1">where</span>
  <span class="kw3">fmap</span> <span class="sy0">_</span> <span class="br0">&#91;</span><span class="br0">&#93;</span>     <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#93;</span>
  <span class="kw3">fmap</span> g <span class="br0">&#40;</span>x:xs<span class="br0">&#41;</span> <span class="sy0">=</span> g x&#160;: <span class="kw3">fmap</span> g xs
  <span class="co1">-- or we could just say fmap = map</span>
&#160;
<span class="kw1">instance</span> <span class="kw4">Functor</span> <span class="kw4">Maybe</span> <span class="kw1">where</span>
  <span class="kw3">fmap</span> <span class="sy0">_</span> Nothing  <span class="sy0">=</span> Nothing
  <span class="kw3">fmap</span> g <span class="br0">&#40;</span>Just a<span class="br0">&#41;</span> <span class="sy0">=</span> Just <span class="br0">&#40;</span>g a<span class="br0">&#41;</span></pre></div></div>
<p>As an aside, in idiomatic Haskell code you will often see the letter <code>f</code> used to stand for both an arbitrary <code>Functor</code> and an arbitrary function. In this document, <code>f</code> represents only <code>Functor</code>s, and <code>g</code> or <code>h</code> always represent functions, but you should be aware of the potential confusion. In practice, what <code>f</code> stands for should always be clear from the context, by noting whether it is part of a type or part of the code.
</p><p>There are other <code>Functor</code> instances in the standard libraries; below are a few. Note that some of these instances are not exported by the <code>Prelude</code>; to access them, you can import <code>Control.Monad.Instances</code>.
</p>
<ul><li> <code>Either e</code> is an instance of <code>Functor</code>; <code>Either e a</code> represents a container which can contain either a value of type <code>a</code>, or a value of type <code>e</code> (often representing some sort of error condition). It is similar to <code>Maybe</code> in that it represents possible failure, but it can carry some extra information about the failure as well.
</li></ul>
<ul><li> <code>((,) e)</code> represents a container which holds an “annotation” of type <code>e</code> along with the actual value it holds. It might be clearer to write it as <code>(e,)</code>, by analogy with an operator section like <code>(1+)</code>, but that syntax is not allowed in types (although it is allowed in expressions with the <code>TupleSections</code> extension enabled). However, you can certainly <i>think</i> of it as <code>(e,)</code>.
</li></ul>
<ul><li> <code>((-&gt;) e)</code> (which can be thought of as <code>(e -&gt;)</code>; see above), the type of functions which take a value of type <code>e</code> as a parameter, is a <code>Functor</code>.  As a container, <code>(e -&gt; a)</code> represents a (possibly infinite) set of values of <code>a</code>, indexed by values of <code>e</code>. Alternatively, and more usefully, <code>((-&gt;) e)</code> can be thought of as a context in which a value of type <code>e</code> is available to be consulted in a read-only fashion. This is also why <code>((-&gt;) e)</code> is sometimes referred to as the <i>reader monad</i>; more on this later.
</li></ul>
<ul><li> <code>IO</code> is a <code>Functor</code>; a value of type <code>IO a</code> represents a computation producing a value of type <code>a</code> which may have I/O effects. If <code>m</code> computes the value <code>x</code> while producing some I/O effects, then <code>fmap g m</code> will compute the value <code>g x</code> while producing the same I/O effects.
</li></ul>
<ul><li> Many standard types from the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/containers/">containers library</a> (such as <code>Tree</code>, <code>Map</code>, and <code>Sequence</code>) are instances of <code>Functor</code>. A notable exception is <code>Set</code>, which cannot be made a <code>Functor</code> in Haskell (although it is certainly a mathematical functor) since it requires an <code>Ord</code> constraint on its elements; <code>fmap</code> must be applicable to <i>any</i> types <code>a</code> and <code>b</code>. However, <code>Set</code> (and other similarly restricted data types) can be made an instance of a suitable generalization of <code>Functor</code>, either by <a rel="nofollow" class="external text" href="http://article.gmane.org/gmane.comp.lang.haskell.cafe/78052/">making <code>a</code> and <code>b</code> arguments to the <code>Functor</code> type class themselves</a>, or by adding an <a rel="nofollow" class="external text" href="http://blog.omega-prime.co.uk/?p=127">associated constraint</a>.
</li></ul>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol>
<li>Implement <code>Functor</code> instances for <code>Either e</code> and <code>((-&gt;) e)</code>.</li>
<li>Implement <code>Functor</code> instances for <code>((,) e)</code> and for <code>Pair</code>, defined as 

<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">data</span> Pair a <span class="sy0">=</span> Pair a a</pre></div></div>
<p>Explain their similarities and differences.
</p>
</li>
<li>Implement a <code>Functor</code> instance for the type <code>ITree</code>, defined as

<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">data</span> ITree a <span class="sy0">=</span> Leaf <span class="br0">&#40;</span><span class="kw4">Int</span> <span class="sy0">-&gt;</span> a<span class="br0">&#41;</span> 
             <span class="sy0">|</span> Node <span class="br0">&#91;</span>ITree a<span class="br0">&#93;</span></pre></div></div>
</li>
<li>Give an example of a type of kind <code>* -&gt; *</code> which cannot be made an instance of <code>Functor</code> (without using <code>undefined</code>).
</li>
<li>Is this statement true or false? 

<dl><dd><i>The composition of two <code>Functor</code>s is also a <code>Functor</code>.</i>
</dd></dl>

If false, give a counterexample; if true, prove it by exhibiting some appropriate Haskell code.
</li>
</ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Laws">3.3 Laws</span></h2>
<p>As far as the Haskell language itself is concerned, the only requirement to be a <code>Functor</code> is an implementation of <code>fmap</code> with the proper type. Any sensible <code>Functor</code> instance, however, will also satisfy the <i>functor laws</i>, which are part of the definition of a mathematical functor. There are two:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw3">fmap</span> <span class="kw3">id</span> <span class="sy0">=</span> <span class="kw3">id</span>
<span class="kw3">fmap</span> <span class="br0">&#40;</span>g <span class="sy0">.</span> h<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="kw3">fmap</span> g<span class="br0">&#41;</span> <span class="sy0">.</span> <span class="br0">&#40;</span><span class="kw3">fmap</span> h<span class="br0">&#41;</span></pre></div></div>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Technically, these laws make <code>f</code> and <code>fmap</code> together an endofunctor on <i>Hask</i>, the category of Haskell types (ignoring <a href="/haskellwiki/Bottom" title="Bottom">&#8869;</a>, which is a party pooper). See <a rel="nofollow" class="external text" href="http://en.wikibooks.org/wiki/Haskell/Category_theory">Wikibook: Category theory</a>.</span>
</p><p>Together, these laws ensure that <code>fmap g</code> does not change the <i>structure</i> of a container, only the elements. Equivalently, and more simply, they ensure that <code>fmap g</code> changes a value without altering its context <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.
</p><p>The first law says that mapping the identity function over every item in a container has no effect. The second says that mapping a composition of two functions over every item in a container is the same as first mapping one function, and then mapping the other.
</p><p>As an example, the following code is a “valid” instance of <code>Functor</code> (it typechecks), but it violates the functor laws. Do you see why?
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="co1">-- Evil Functor instance</span>
<span class="kw1">instance</span> <span class="kw4">Functor</span> <span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="kw1">where</span>
  <span class="kw3">fmap</span> <span class="sy0">_</span> <span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#91;</span><span class="br0">&#93;</span>
  <span class="kw3">fmap</span> g <span class="br0">&#40;</span>x:xs<span class="br0">&#41;</span> <span class="sy0">=</span> g x&#160;: g x&#160;: <span class="kw3">fmap</span> g xs</pre></div></div>
<p>Any Haskeller worth their salt would reject this code as a gruesome abomination.
</p><p>Unlike some other type classes we will encounter, a given type has at most one valid instance of <code>Functor</code>. This <a rel="nofollow" class="external text" href="http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384">can be proven</a> via the <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html#free"><i>free theorem</i></a> for the type of <code>fmap</code>.  In fact, <a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/2010/03/03/deriving-pleasure-from-ghc-6-12-1/">GHC can automatically derive</a> <code>Functor</code> instances for many data types.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Actually, if <code>seq</code>/<code>undefined</code> are considered, it <a rel="nofollow" class="external text" href="http://stackoverflow.com/a/8323243/305559">is possible</a> to have an implementation which satisfies the first law but not the second.  The rest of the comments in this section should considered in a context where <code>seq</code> and <code>undefined</code> are excluded.</span>
</p><p>A <a rel="nofollow" class="external text" href="https://github.com/quchen/articles/blob/master/second_functor_law.md">similar argument also shows</a> that any <code>Functor</code> instance satisfying the first law (<code>fmap id = id</code>) will automatically satisfy the second law as well.  Practically, this means that only the first law needs to be checked (usually by a very straightforward induction) to ensure that a <code>Functor</code> instance is valid.<span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> Although it is not possible for a <code>Functor</code> instance to satisfy the first <code>Functor</code> law but not the second (excluding <code>undefined</code>), the reverse is possible. Give an example of a (bogus) <code>Functor</code> instance which satisfies the second law but not the first.
</li><li> Which laws are violated by the evil <code>Functor</code> instance for list shown above: both laws, or the first law alone? Give specific counterexamples.
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Intuition">3.4 Intuition</span></h2>
<p>There are two fundamental ways to think about <code>fmap</code>. The first has already been mentioned: it takes two parameters, a function and a container, and applies the function “inside” the container, producing a new container. Alternately, we can think of <code>fmap</code> as applying a function to a value in a context (without altering the context).
</p><p>Just like all other Haskell functions of “more than one parameter”, however, <code>fmap</code> is actually <i>curried</i>: it does not really take two parameters, but takes a single parameter and returns a function. For emphasis, we can write <code>fmap</code>’s type with extra parentheses: <code>fmap&#160;:: (a -&gt; b) -&gt; (f a -&gt; f b)</code>. Written in this form, it is apparent that <code>fmap</code> transforms a “normal” function (<code>g&#160;:: a -&gt; b</code>) into one which operates over containers/contexts (<code>fmap g&#160;:: f a -&gt; f b</code>). This transformation is often referred to as a <i>lift</i>; <code>fmap</code> “lifts” a function from the “normal world” into the “<code>f</code> world”.
</p>
<h2> <span class="mw-headline" id="Further_reading">3.5 Further reading</span></h2>
<p>A good starting point for reading about the category theory behind the concept of a functor is the excellent <a rel="nofollow" class="external text" href="http://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell wikibook page on category theory</a>.
</p>
<h1> <span class="mw-headline" id="Applicative">4 Applicative</span></h1>
<p>A somewhat newer addition to the pantheon of standard Haskell type classes, <i>applicative functors</i> represent an abstraction lying in between <code>Functor</code> and <code>Monad</code> in expressivity, first described by McBride and Paterson. The title of their classic paper, <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html">Applicative Programming with Effects</a>, gives a hint at the intended intuition behind the <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html"><code>Applicative</code></a> type class. It encapsulates certain sorts of “effectful” computations in a functionally pure way, and encourages an “applicative” programming style. Exactly what these things mean will be seen later.
</p>
<h2> <span class="mw-headline" id="Definition_2">4.1 Definition</span></h2>
<p>Recall that <code>Functor</code> allows us to lift a “normal” function to a function on computational contexts. But <code>fmap</code> doesn’t allow us to apply a function which is itself in a context to a value in a context. <code>Applicative</code> gives us just such a tool, <code>(&lt;*&gt;)</code>. It also provides a method, <code>pure</code>, for embedding values in a default, “effect free” context.  Here is the type class declaration for <code>Applicative</code>, as defined in <code>Control.Applicative</code>:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> <span class="kw4">Functor</span> f <span class="sy0">=&gt;</span> Applicative f <span class="kw1">where</span>
  pure  <span class="sy0">::</span> a <span class="sy0">-&gt;</span> f a
  <span class="br0">&#40;</span><span class="sy0">&lt;*&gt;</span><span class="br0">&#41;</span> <span class="sy0">::</span> f <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> f a <span class="sy0">-&gt;</span> f b</pre></div></div>
<p>Note that every <code>Applicative</code> must also be a <code>Functor</code>. In fact, as we will see, <code>fmap</code> can be implemented using the <code>Applicative</code> methods, so every <code>Applicative</code> is a functor whether we like it or not; the <code>Functor</code> constraint forces us to be honest.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Recall that <code>($)</code> is just function application: <code>f $ x = f x</code>.</span>
</p><p>As always, it’s crucial to understand the type signatures.  First, consider <code>(&lt;*&gt;)</code>: the best way of thinking about it comes from noting that the type of <code>(&lt;*&gt;)</code> is similar to the type of <code>($)</code> <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>, but with everything enclosed in an <code>f</code>. In other words, <code>(&lt;*&gt;)</code> is just function application within a computational context. The type of <code>(&lt;*&gt;)</code> is also very similar to the type of <code>fmap</code>; the only difference is that the first parameter is <code>f (a -&gt; b)</code>, a function in a context, instead of a “normal” function <code>(a -&gt; b)</code>.
</p><p><code>pure</code> takes a value of any type <code>a</code>, and returns a context/container of type <code>f a</code>.  The intention is that <code>pure</code> creates some sort of “default” container or “effect free” context.  In fact, the behavior of <code>pure</code> is quite constrained by the laws it should satisfy in conjunction with <code>(&lt;*&gt;)</code>.  Usually, for a given implementation of <code>(&lt;*&gt;)</code> there is only one possible implementation of <code>pure</code>.
</p><p>(Note that previous versions of the Typeclassopedia explained <code>pure</code> in terms of a type class <code>Pointed</code>, which can still be found in the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/pointed"><code>pointed</code> package</a>.  However, the current consensus is that <code>Pointed</code> is not very useful after all.  For a more detailed explanation, see <a href="/haskellwiki/Why_not_Pointed%3F" title="Why not Pointed?">Why not Pointed?</a>)
</p>
<h2> <span class="mw-headline" id="Laws_2">4.2 Laws</span></h2>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ See
<a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html">haddock for Applicative</a> and <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html">Applicative programming with effects</a></span>
</p><p>Traditionally, there are four laws that <code>Applicative</code> instances should satisfy <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.  In some sense, they are all concerned with making sure that <code>pure</code> deserves its name:
</p>
<ul><li> The identity law:<br /><div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">pure <span class="kw3">id</span> <span class="sy0">&lt;*&gt;</span> v <span class="sy0">=</span> v</pre></div></div>
</li><li> Homomorphism:<br /><div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">pure f <span class="sy0">&lt;*&gt;</span> pure x <span class="sy0">=</span> pure <span class="br0">&#40;</span>f x<span class="br0">&#41;</span></pre></div></div>Intuitively, applying a non-effectful function to a non-effectful argument in an effectful context is the same as just applying the function to the argument and then injecting the result into the context with <code>pure</code>.
</li><li> Interchange:<br /><div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">u <span class="sy0">&lt;*&gt;</span> pure y <span class="sy0">=</span> pure <span class="br0">&#40;</span><span class="sy0">$</span> y<span class="br0">&#41;</span> <span class="sy0">&lt;*&gt;</span> u</pre></div></div>Intuitively, this says that when evaluating the application of an effectful function to a pure argument, the order in which we evaluate the function and its argument doesn't matter.
</li><li> Composition:<br /><div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">u <span class="sy0">&lt;*&gt;</span> <span class="br0">&#40;</span>v <span class="sy0">&lt;*&gt;</span> w<span class="br0">&#41;</span> <span class="sy0">=</span> pure <span class="br0">&#40;</span><span class="sy0">.</span><span class="br0">&#41;</span> <span class="sy0">&lt;*&gt;</span> u <span class="sy0">&lt;*&gt;</span> v <span class="sy0">&lt;*&gt;</span> w</pre></div></div>This one is the trickiest law to gain intuition for.  In some sense it is expressing a sort of associativity property of <code>(&lt;*&gt;)</code>.  The reader may wish to simply convince themselves  that this law is type-correct.
</li></ul>
<p>Considered as left-to-right rewrite rules, the homomorphism, interchange, and composition laws actually constitute an algorithm for transforming any expression using <code>pure</code> and <code>(&lt;*&gt;)</code> into a canonical form with only a single use of <code>pure</code> at the very beginning and only left-nested occurrences of <code>(&lt;*&gt;)</code>.  Composition allows reassociating <code>(&lt;*&gt;)</code>; interchange allows moving occurrences of <code>pure</code> leftwards; and homomorphism allows collapsing multiple adjacent occurrences of <code>pure</code> into one.
</p><p>There is also a law specifying how <code>Applicative</code> should relate to <code>Functor</code>:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw3">fmap</span> g x <span class="sy0">=</span> pure g <span class="sy0">&lt;*&gt;</span> x</pre></div></div>
<p>It says that mapping a pure function <code>g</code> over a context <code>x</code> is the same as first injecting <code>g</code> into a context with <code>pure</code>, and then applying it to <code>x</code> with <code>(&lt;*&gt;)</code>. In other words, we can decompose <code>fmap</code> into two more atomic operations: injection into a context, and application within a context. The <code>Control.Applicative</code> module also defines <code>(&lt;$&gt;)</code> as a synonym for <code>fmap</code>, so the above law can also be expressed as:
</p><p><code>g &lt;$&gt; x = pure g &lt;*&gt; x</code>.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> (Tricky) One might imagine a variant of the interchange law that says something about applying a pure function to an effectful argument.  Using the above laws, prove that<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">pure f <span class="sy0">&lt;*&gt;</span> x <span class="sy0">=</span> pure <span class="br0">&#40;</span><span class="kw3">flip</span> <span class="br0">&#40;</span><span class="sy0">$</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&lt;*&gt;</span> x <span class="sy0">&lt;*&gt;</span> pure f</pre></div></div>
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Instances_2">4.3 Instances</span></h2>
<p>Most of the standard types which are instances of <code>Functor</code> are also instances of <code>Applicative</code>.
</p><p><code>Maybe</code> can easily be made an instance of <code>Applicative</code>; writing such an instance is left as an exercise for the reader.
</p><p>The list type constructor <code>[]</code> can actually be made an instance of <code>Applicative</code> in two ways; essentially, it comes down to whether we want to think of lists as ordered collections of elements, or as contexts representing multiple results of a nondeterministic computation (see Wadler’s <a rel="nofollow" class="external text" href="http://www.springerlink.com/content/y7450255v2670167/">How to replace failure by a list of successes</a>).
</p><p>Let’s first consider the collection point of view.  Since there can only be one instance of a given type class for any particular type, one or both of the list instances of <code>Applicative</code> need to be defined for a <code>newtype</code> wrapper; as it happens, the nondeterministic computation instance is the default, and the collection instance is defined in terms of a <code>newtype</code> called <code>ZipList</code>. This instance is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">newtype</span> ZipList a <span class="sy0">=</span> ZipList <span class="br0">&#123;</span> getZipList <span class="sy0">::</span> <span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="br0">&#125;</span>
&#160;
<span class="kw1">instance</span> Applicative ZipList <span class="kw1">where</span>
  pure <span class="sy0">=</span> <span class="kw3">undefined</span>   <span class="co1">-- exercise</span>
  <span class="br0">&#40;</span>ZipList gs<span class="br0">&#41;</span> <span class="sy0">&lt;*&gt;</span> <span class="br0">&#40;</span>ZipList xs<span class="br0">&#41;</span> <span class="sy0">=</span> ZipList <span class="br0">&#40;</span><span class="kw3">zipWith</span> <span class="br0">&#40;</span><span class="sy0">$</span><span class="br0">&#41;</span> gs xs<span class="br0">&#41;</span></pre></div></div>
<p>To apply a list of functions to a list of inputs with <code>(&lt;*&gt;)</code>, we just match up the functions and inputs elementwise, and produce a list of the resulting outputs. In other words, we “zip” the lists together with function application, <code>($)</code>; hence the name <code>ZipList</code>. 
</p><p>The other <code>Applicative</code> instance for lists, based on the nondeterministic computation point of view, is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">instance</span> Applicative <span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="kw1">where</span>
  pure x    <span class="sy0">=</span> <span class="br0">&#91;</span>x<span class="br0">&#93;</span>
  gs <span class="sy0">&lt;*&gt;</span> xs <span class="sy0">=</span> <span class="br0">&#91;</span> g x <span class="sy0">|</span> g <span class="sy0">&lt;-</span> gs<span class="sy0">,</span> x <span class="sy0">&lt;-</span> xs <span class="br0">&#93;</span></pre></div></div>
<p>Instead of applying functions to inputs pairwise, we apply each function to all the inputs in turn, and collect all the results in a list.
</p><p>Now we can write nondeterministic computations in a natural style. To add the numbers <code>3</code> and <code>4</code> deterministically, we can of course write <code>(+) 3 4</code>. But suppose instead of <code>3</code> we have a nondeterministic computation that might result in <code>2</code>, <code>3</code>, or <code>4</code>; then we can write
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  pure <span class="br0">&#40;</span><span class="sy0">+</span><span class="br0">&#41;</span> <span class="sy0">&lt;*&gt;</span> <span class="br0">&#91;</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">&lt;*&gt;</span> pure <span class="nu0">4</span></pre></div></div>
<p>or, more idiomatically,
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  <span class="br0">&#40;</span><span class="sy0">+</span><span class="br0">&#41;</span> <span class="sy0">&lt;$&gt;</span> <span class="br0">&#91;</span><span class="nu0">2</span><span class="sy0">,</span><span class="nu0">3</span><span class="sy0">,</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">&lt;*&gt;</span> pure <span class="nu0">4</span><span class="sy0">.</span></pre></div></div>
<p>There are several other <code>Applicative</code> instances as well:
</p>
<ul><li> <code>IO</code> is an instance of <code>Applicative</code>, and behaves exactly as you would think: to execute <code>m1 &lt;*&gt; m2</code>, first <code>m1</code> is executed, resulting in a function <code>f</code>, then <code>m2</code> is executed, resulting in a value <code>x</code>, and finally the value <code>f x</code> is returned as the result of executing <code>m1 &lt;*&gt; m2</code>.
</li></ul>
<ul><li> <code>((,) a)</code> is an <code>Applicative</code>, as long as <code>a</code> is an instance of <code>Monoid</code> (<a href="#Monoid">section Monoid</a>). The <code>a</code> values are accumulated in parallel with the computation.
</li></ul>
<ul><li> The <code>Applicative</code> module defines the <code>Const</code> type constructor; a value of type <code>Const a b</code> simply contains an <code>a</code>. This is an instance of <code>Applicative</code> for any <code>Monoid a</code>; this instance becomes especially useful in conjunction with things like <code>Foldable</code> (<a href="#Foldable">section Foldable</a>).
</li></ul>
<ul><li> The <code>WrappedMonad</code> and <code>WrappedArrow</code> newtypes make any instances of <code>Monad</code> (<a href="#Monad">section Monad</a>) or <code>Arrow</code> (<a href="#Arrow">section Arrow</a>) respectively into instances of <code>Applicative</code>; as we will see when we study those type classes, both are strictly more expressive than <code>Applicative</code>, in the sense that the <code>Applicative</code> methods can be implemented in terms of their methods.
</li></ul>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> Implement an instance of <code>Applicative</code> for <code>Maybe</code>.
</li><li> Determine the correct definition of <code>pure</code> for the <code>ZipList</code> instance of <code>Applicative</code>—there is only one implementation that satisfies the law relating <code>pure</code> and <code>(&lt;*&gt;)</code>.
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Intuition_2">4.4 Intuition</span></h2>
<p>McBride and Paterson’s paper introduces the notation <img class="tex" alt="[[g \; x_1 \; x_2 \; \cdots \; x_n]]\ " src="/wikiupload/math/b/1/f/b1fc0ea10067f5768b54a245b40bb25c.png" /> to denote function application in a computational context. If each <img class="tex" alt="x_i\ " src="/wikiupload/math/0/4/2/0424ddf948e53cc231b908a0c1031a04.png" /> has type <img class="tex" alt="f \; t_i\ " src="/wikiupload/math/6/b/4/6b456c40db02edacf621c64861a6eb13.png" /> for some applicative functor <img class="tex" alt="f\ " src="/wikiupload/math/1/2/3/123aeec2a5af89d9f40e5ecb2228234a.png" />, and <img class="tex" alt="g\ " src="/wikiupload/math/0/c/c/0ccb9952a2e9361d2eb3047c46f24ef1.png" /> has type <img class="tex" alt="t_1 \to t_2 \to \dots \to t_n \to t\ " src="/wikiupload/math/8/0/f/80fc7715f859c8660e48bbd43bef2455.png" />, then the entire expression <img class="tex" alt="[[g \; x_1 \; \cdots \; x_n]]\ " src="/wikiupload/math/a/f/6/af6a83cb59a08499517dfa7562d57dc2.png" /> has type <img class="tex" alt="f \; t\ " src="/wikiupload/math/0/8/4/084a682a3320c4380d86aeb8e9a2beeb.png" />. You can think of this as applying a function to multiple “effectful” arguments. In this sense, the double bracket notation is a generalization of <code>fmap</code>, which allows us to apply a function to a single argument in a context.
</p><p>Why do we need <code>Applicative</code> to implement this generalization of <code>fmap</code>? Suppose we use <code>fmap</code> to apply <code>g</code> to the first parameter <code>x1</code>. Then we get something of type <code>f (t2 -&gt; ... t)</code>, but now we are stuck: we can’t apply this function-in-a-context to the next argument with <code>fmap</code>. However, this is precisely what <code>(&lt;*&gt;)</code> allows us to do.
</p><p>This suggests the proper translation of the idealized notation <img class="tex" alt="[[g \; x_1 \; x_2 \; \cdots \; x_n]]\ " src="/wikiupload/math/b/1/f/b1fc0ea10067f5768b54a245b40bb25c.png" /> into Haskell, namely
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  g <span class="sy0">&lt;$&gt;</span> x1 <span class="sy0">&lt;*&gt;</span> x2 <span class="sy0">&lt;*&gt;</span> <span class="sy0">...</span> <span class="sy0">&lt;*&gt;</span> xn<span class="sy0">,</span></pre></div></div>
<p>recalling that <code>Control.Applicative</code> defines <code>(&lt;$&gt;)</code> as convenient infix shorthand for <code>fmap</code>. This is what is meant by an “applicative style”—effectful computations can still be described in terms of function application; the only difference is that we have to use the special operator <code>(&lt;*&gt;)</code> for application instead of simple juxtaposition.
</p><p>Note that <code>pure</code> allows embedding “non-effectful” arguments in the middle of an idiomatic application, like
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  g <span class="sy0">&lt;$&gt;</span> x1 <span class="sy0">&lt;*&gt;</span> pure x2 <span class="sy0">&lt;*&gt;</span> x3</pre></div></div>
<p>which has type <code>f d</code>, given
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">g  <span class="sy0">::</span> a <span class="sy0">-&gt;</span> b <span class="sy0">-&gt;</span> c <span class="sy0">-&gt;</span> d
x1 <span class="sy0">::</span> f a
x2 <span class="sy0">::</span> b
x3 <span class="sy0">::</span> f c</pre></div></div>
<p>The double brackets are commonly known as “idiom brackets”, because they allow writing “idiomatic” function application, that is, function application that looks normal but has some special, non-standard meaning (determined by the particular instance of <code>Applicative</code> being used).  Idiom brackets are not supported by GHC, but they are supported by the <a rel="nofollow" class="external text" href="http://personal.cis.strath.ac.uk/~conor/pub/she/">Strathclyde Haskell Enhancement</a>, a preprocessor which (among many other things) translates idiom brackets into standard uses of <code>(&lt;$&gt;)</code> and <code>(&lt;*&gt;)</code>.  This can result in much more readable code when making heavy use of <code>Applicative</code>.
</p>
<h2> <span class="mw-headline" id="Alternative_formulation">4.5 Alternative formulation</span></h2>
<p>An alternative, equivalent formulation of <code>Applicative</code> is given by
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> <span class="kw4">Functor</span> f <span class="sy0">=&gt;</span> Monoidal f <span class="kw1">where</span>
  unit <span class="sy0">::</span> f <span class="br0">&#40;</span><span class="br0">&#41;</span>
  <span class="br0">&#40;</span><span class="sy0">**</span><span class="br0">&#41;</span> <span class="sy0">::</span> f a <span class="sy0">-&gt;</span> f b <span class="sy0">-&gt;</span> f <span class="br0">&#40;</span>a<span class="sy0">,</span>b<span class="br0">&#41;</span></pre></div></div>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ In category-theory speak, we say <code>f</code> is a <i>lax</i> monoidal functor because there aren't necessarily functions in the other direction, like <code>f (a, b) -&gt; (f a, f b)</code>.</span>
Intuitively, this states that a <i>monoidal</i> functor<span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span> is one which has some sort of "default shape" and which supports some sort of "combining" operation.  <code>pure</code> and <code>(&lt;*&gt;)</code> are equivalent in power to <code>unit</code> and <code>(**)</code> (see the Exercises below).  More technically, the idea is that <code>f</code> preserves the "monoidal structure" given by the pairing constructor <code>(,)</code> and unit type <code>()</code>.  This can be seen even more clearly if we rewrite the types of <code>unit</code> and <code>(**)</code> as
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  unit' <span class="sy0">::</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">-&gt;</span> f <span class="br0">&#40;</span><span class="br0">&#41;</span>
  <span class="br0">&#40;</span><span class="sy0">**</span>'<span class="br0">&#41;</span> <span class="sy0">::</span> <span class="br0">&#40;</span>f a<span class="sy0">,</span> f b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> f <span class="br0">&#40;</span>a<span class="sy0">,</span> b<span class="br0">&#41;</span></pre></div></div>
<p>Furthermore, to deserve the name "monoidal" (see the <a href="#Monoid">section on Monoids</a>), instances of <code>Monoidal</code> ought to satisfy the following laws, which seem much more straightforward than the traditional <code>Applicative</code> laws:
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ In this and the following laws, <code>≅</code> refers to <i>isomorphism</i> rather than equality.  In particular we consider <code>(x,()) ≅ x ≅ ((),x)</code> and <code>((x,y),z) ≅ (x,(y,z))</code>.</span>
</p>
<ul><li> Left identity<span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>: <div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">unit <span class="sy0">**</span> v ≅ v</pre></div></div>
</li><li> Right identity: <div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">u <span class="sy0">**</span> unit ≅ u</pre></div></div>
</li><li> Associativity: <div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">u <span class="sy0">**</span> <span class="br0">&#40;</span>v <span class="sy0">**</span> w<span class="br0">&#41;</span> ≅ <span class="br0">&#40;</span>u <span class="sy0">**</span> v<span class="br0">&#41;</span> <span class="sy0">**</span> w</pre></div></div>
</li></ul>
<p>These turn out to be equivalent to the usual <code>Applicative</code> laws. In a category theory setting, one would also require a naturality law:
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Here <code>g *** h = \(x,y) -&gt; (g x, h y)</code>.  See <a href="#Arrow">Arrows</a>.</span>
</p>
<ul><li> Naturality: <div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw3">fmap</span> <span class="br0">&#40;</span>g <span class="sy0">***</span> h<span class="br0">&#41;</span> <span class="br0">&#40;</span>u <span class="sy0">**</span> v<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="kw3">fmap</span> g u <span class="sy0">**</span> <span class="kw3">fmap</span> h v</pre></div></div>
</li></ul>
<p>but in the context of Haskell, this is a free theorem.
</p><p>Much of this section was taken from <a rel="nofollow" class="external text" href="http://blog.ezyang.com/2012/08/applicative-functors/">a blog post by Edward Z. Yang</a>; see his actual post for a bit more information.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> Implement <code>pure</code> and <code>(&lt;*&gt;)</code> in terms of <code>unit</code> and <code>(**)</code>, and vice versa.
</li><li> Are there any <code>Applicative</code> instances for which there are also functions <code>f () -&gt; ()</code> and <code>f (a,b) -&gt; (f a, f b)</code>, satisfying some "reasonable" laws?
</li><li> (Tricky) Prove that given your implementations from the previous exercise, the usual <code>Applicative</code> laws and the <code>Monoidal</code> laws stated above are equivalent.
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Further_reading_2">4.6 Further reading</span></h2>
<p>There are many other useful combinators in the standard libraries implemented in terms of <code>pure</code> and <code>(&lt;*&gt;)</code>: for example, <code>(*&gt;)</code>, <code>(&lt;*)</code>, <code>(&lt;**&gt;)</code>, <code>(&lt;$)</code>, and so on (see <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.7.0.0/Control-Applicative.html">haddock for Applicative</a>). Judicious use of such secondary combinators can often make code using <code>Applicative</code>s much easier to read.
</p><p><a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html">McBride and Paterson’s original paper</a> is a treasure-trove of information and examples, as well as some perspectives on the connection between <code>Applicative</code> and category theory. Beginners will find it difficult to make it through the entire paper, but it is extremely well-motivated—even beginners will be able to glean something from reading as far as they are able.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Introduced by <a rel="nofollow" class="external text" href="http://conal.net/papers/simply-reactive/">an earlier paper</a> that was since superseded by <a rel="nofollow" class="external text" href="http://conal.net/papers/push-pull-frp/">Push-pull functional reactive programming</a>.</span>
</p><p>Conal Elliott has been one of the biggest proponents of <code>Applicative</code>. For example, the <a rel="nofollow" class="external text" href="http://conal.net/papers/functional-images/">Pan library for functional images</a> and the reactive library for functional reactive programming (FRP) <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span> make key use of it; his blog also contains <a rel="nofollow" class="external text" href="http://conal.net/blog/tag/applicative-functor">many examples of <code>Applicative</code> in action</a>. Building on the work of McBride and Paterson, Elliott also built the <a href="/haskellwiki/TypeCompose" title="TypeCompose">TypeCompose</a> library, which embodies the observation (among others) that <code>Applicative</code> types are closed under composition; therefore, <code>Applicative</code> instances can often be automatically derived for complex types built out of simpler ones.
</p><p>Although the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/parsec">Parsec parsing library</a> (<a rel="nofollow" class="external text" href="http://legacy.cs.uu.nl/daan/download/papers/parsec-paper.pdf">paper</a>) was originally designed for use as a monad, in its most common use cases an <code>Applicative</code> instance can be used to great effect; <a rel="nofollow" class="external text" href="http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/">Bryan O’Sullivan’s blog post</a> is a good starting point. If the extra power provided by <code>Monad</code> isn’t needed, it’s usually a good idea to use <code>Applicative</code> instead.
</p><p>A couple other nice examples of <code>Applicative</code> in action include the <a rel="nofollow" class="external text" href="http://web.archive.org/web/20090416111947/chrisdone.com/blog/html/2009-02-10-applicative-configfile-hsql.html">ConfigFile and HSQL libraries</a> and the <a rel="nofollow" class="external text" href="http://groups.inf.ed.ac.uk/links/formlets/">formlets library</a>.
</p><p>Gershom Bazerman's <a rel="nofollow" class="external text" href="http://comonad.com/reader/2012/abstracting-with-applicatives/">post</a> contains many insights into applicatives.
</p>
<h1> <span class="mw-headline" id="Monad">5 Monad</span></h1>
<p>It’s a safe bet that if you’re reading this, you’ve heard of monads—although it’s quite possible you’ve never heard of <code>Applicative</code> before, or <code>Arrow</code>, or even <code>Monoid</code>. Why are monads such a big deal in Haskell? There are several reasons.
</p>
<ul><li> Haskell does, in fact, single out monads for special attention by making them the framework in which to construct I/O operations.
</li><li> Haskell also singles out monads for special attention by providing a special syntactic sugar for monadic expressions: the <code>do</code>-notation.
</li><li> <code>Monad</code> has been around longer than other abstract models of computation such as <code>Applicative</code> or <code>Arrow</code>.
</li><li> The more monad tutorials there are, the harder people think monads must be, and the more new monad tutorials are written by people who think they finally “get” monads (the <a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">monad tutorial fallacy</a>).
</li></ul>
<p>I will let you judge for yourself whether these are good reasons.
</p><p>In the end, despite all the hoopla, <code>Monad</code> is just another type class. Let’s take a look at its definition.
</p>
<h2> <span class="mw-headline" id="Definition_3">5.1 Definition</span></h2>
<p>The type class declaration for <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad"><code>Monad</code></a> is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> <span class="kw4">Monad</span> m <span class="kw1">where</span>
  <span class="kw3">return</span> <span class="sy0">::</span> a <span class="sy0">-&gt;</span> m a
  <span class="br0">&#40;</span><span class="sy0">&gt;&gt;=</span><span class="br0">&#41;</span>  <span class="sy0">::</span> m a <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> m b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> m b
  <span class="br0">&#40;</span><span class="sy0">&gt;&gt;</span><span class="br0">&#41;</span>   <span class="sy0">::</span> m a <span class="sy0">-&gt;</span> m b <span class="sy0">-&gt;</span> m b
  m <span class="sy0">&gt;&gt;</span> n <span class="sy0">=</span> m <span class="sy0">&gt;&gt;=</span> \<span class="sy0">_</span> <span class="sy0">-&gt;</span> n
&#160;
  <span class="kw3">fail</span>   <span class="sy0">::</span> <span class="kw4">String</span> <span class="sy0">-&gt;</span> m a</pre></div></div>
<p>The <code>Monad</code> type class is exported by the <code>Prelude</code>, along with a few standard instances. However, many utility functions are found in <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html"><code>Control.Monad</code></a>, and there are also several instances (such as <code>((-&gt;) e)</code>) defined in <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Instances.html"><code>Control.Monad.Instances</code></a>.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ However, as of GHC 7.10 this will be fixed!</span>
Let’s examine the methods in the <code>Monad</code> class one by one. The type of <code>return</code> should look familiar; it’s the same as <code>pure</code>. Indeed, <code>return</code> <i>is</i> <code>pure</code>, but with an unfortunate name. (Unfortunate, since someone coming from an imperative programming background might think that <code>return</code> is like the C or Java keyword of the same name, when in fact the similarities are minimal.) From a mathematical point of view, every monad is an applicative functor, but for historical reasons, the <code>Monad</code> type class declaration unfortunately does not require this.<span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>
</p><p>We can see that <code>(&gt;&gt;)</code> is a specialized version of <code>(&gt;&gt;=)</code>, with a default implementation given. It is only included in the type class declaration so that specific instances of <code>Monad</code> can override the default implementation of <code>(&gt;&gt;)</code> with a more efficient one, if desired. Also, note that although <code>_ &gt;&gt; n = n</code> would be a type-correct implementation of <code>(&gt;&gt;)</code>, it would not correspond to the intended semantics: the intention is that <code>m &gt;&gt; n</code> ignores the <i>result</i> of <code>m</code>, but not its <i>effects</i>.
</p><p>The <code>fail</code> function is an awful hack that has no place in the <code>Monad</code> class; more on this later.
</p><p>The only really interesting thing to look at—and what makes <code>Monad</code> strictly more powerful than <code>Applicative</code>—is <code>(&gt;&gt;=)</code>, which is often called <i>bind</i>. An alternative definition of <code>Monad</code> could look like:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Applicative m <span class="sy0">=&gt;</span> <span class="kw4">Monad</span>' m <span class="kw1">where</span>
  <span class="br0">&#40;</span><span class="sy0">&gt;&gt;=</span><span class="br0">&#41;</span> <span class="sy0">::</span> m a <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> m b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> m b</pre></div></div>
<p>We could spend a while talking about the intuition behind <code>(&gt;&gt;=)</code>—and we will. But first, let’s look at some examples.
</p>
<h2> <span class="mw-headline" id="Instances_3">5.2 Instances</span></h2>
<p>Even if you don’t understand the intuition behind the <code>Monad</code> class, you can still create instances of it by just seeing where the types lead you. You may be surprised to find that this actually gets you a long way towards understanding the intuition; at the very least, it will give you some concrete examples to play with as you read more about the <code>Monad</code> class in general. The first few examples are from the standard <code>Prelude</code>; the remaining examples are from the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/transformers"><code>transformers</code> package</a>.
</p>
<ul>
<li>The simplest possible instance of <code>Monad</code> is <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Identity.html"><code>Identity</code></a>, which is described in Dan Piponi’s highly recommended blog post on <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2007/04/trivial-monad.html">The Trivial Monad</a>. Despite being “trivial”, it is a great introduction to the <code>Monad</code> type class, and contains some good exercises to get your brain working.
</li>
<li>The next simplest instance of <code>Monad</code> is <code>Maybe</code>. We already know how to write <code>return</code>/<code>pure</code> for <code>Maybe</code>. So how do we write <code>(&gt;&gt;=)</code>? Well, let’s think about its type. Specializing for <code>Maybe</code>, we have

<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="br0">&#40;</span><span class="sy0">&gt;&gt;=</span><span class="br0">&#41;</span> <span class="sy0">::</span> <span class="kw4">Maybe</span> a <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> b<span class="sy0">.</span></pre></div></div>
<p>If the first argument to <code>(&gt;&gt;=)</code> is <code>Just x</code>, then we have something of type <code>a</code> (namely, <code>x</code>), to which we can apply the second argument—resulting in a <code>Maybe b</code>, which is exactly what we wanted. What if the first argument to <code>(&gt;&gt;=)</code> is <code>Nothing</code>? In that case, we don’t have anything to which we can apply the <code>a -&gt; Maybe b</code> function, so there’s only one thing we can do: yield <code>Nothing</code>. This instance is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">instance</span> <span class="kw4">Monad</span> <span class="kw4">Maybe</span> <span class="kw1">where</span>
  <span class="kw3">return</span> <span class="sy0">=</span> Just
  <span class="br0">&#40;</span>Just x<span class="br0">&#41;</span> <span class="sy0">&gt;&gt;=</span> g <span class="sy0">=</span> g x
  Nothing  <span class="sy0">&gt;&gt;=</span> <span class="sy0">_</span> <span class="sy0">=</span> Nothing</pre></div></div>
<p>We can already get a bit of intuition as to what is going on here: if we build up a computation by chaining together a bunch of functions with <code>(&gt;&gt;=)</code>, as soon as any one of them fails, the entire computation will fail (because <code>Nothing &gt;&gt;= f</code> is <code>Nothing</code>, no matter what <code>f</code> is). The entire computation succeeds only if all the constituent functions individually succeed. So the <code>Maybe</code> monad models computations which may fail.
</p>
</li>
<li>The <code>Monad</code> instance for the list constructor <code>[]</code> is similar to its <code>Applicative</code> instance; see the exercise below.
</li>
<li>Of course, the <code>IO</code> constructor is famously a <code>Monad</code>, but its implementation is somewhat magical, and may in fact differ from compiler to compiler. It is worth emphasizing that the <code>IO</code> monad is the <i>only</i> monad which is magical. It allows us to build up, in an entirely pure way, values representing possibly effectful computations. The special value <code>main</code>, of type <code>IO ()</code>, is taken by the runtime and actually executed, producing actual effects. Every other monad is functionally pure, and requires no special compiler support. We often speak of monadic values as “effectful computations”, but this is because some monads allow us to write code <i>as if</i> it has side effects, when in fact the monad is hiding the plumbing which allows these apparent side effects to be implemented in a functionally pure way.
</li>
<li>As mentioned earlier, <code>((-&gt;) e)</code> is known as the <i>reader monad</i>, since it describes computations in which a value of type <code>e</code> is available as a read-only environment.

The <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Reader.html"><code>Control.Monad.Reader</code></a> module provides the <code>Reader e a</code> type, which is just a convenient <code>newtype</code> wrapper around <code>(e -&gt; a)</code>, along with an appropriate <code>Monad</code> instance and some <code>Reader</code>-specific utility functions such as <code>ask</code> (retrieve the environment), <code>asks</code> (retrieve a function of the environment), and <code>local</code> (run a subcomputation under a different environment).
</li>
<li>The <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Writer-Lazy.html"><code>Control.Monad.Writer</code></a> module provides the <code>Writer</code> monad, which allows information to be collected as a computation progresses. <code>Writer w a</code> is isomorphic to <code>(a,w)</code>, where the output value <code>a</code> is carried along with an annotation or “log” of type <code>w</code>, which must be an instance of <code>Monoid</code> (see <a href="#Monoid">section Monoid</a>); the special function <code>tell</code> performs logging.
</li>
<li>The <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Lazy.html"><code>Control.Monad.State</code></a> module provides the <code>State s a</code> type, a <code>newtype</code> wrapper around <code>s -&gt; (a,s)</code>. Something of type <code>State s a</code> represents a stateful computation which produces an <code>a</code> but can access and modify the state of type <code>s</code> along the way. The module also provides <code>State</code>-specific utility functions such as <code>get</code> (read the current state), <code>gets</code> (read a function of the current state), <code>put</code> (overwrite the state), and <code>modify</code> (apply a function to the state).
</li>
<li>The <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Cont.html"><code>Control.Monad.Cont</code></a> module provides the <code>Cont</code> monad, which represents computations in continuation-passing style. It can be used to suspend and resume computations, and to implement non-local transfers of control, co-routines, other complex control structures—all in a functionally pure way. <code>Cont</code> has been called the <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2008/12/mother-of-all-monads.html">“mother of all monads”</a> because of its universal properties.
</li>
</ul>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol>
<li>Implement a <code>Monad</code> instance for the list constructor, <code>[]</code>. Follow the types!</li>
<li>Implement a <code>Monad</code> instance for <code>((-&gt;) e)</code>.</li>
<li>Implement <code>Functor</code> and <code>Monad</code> instances for <code>Free f</code>, defined as
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">data</span> Free f a <span class="sy0">=</span> Var a
              <span class="sy0">|</span> Node <span class="br0">&#40;</span>f <span class="br0">&#40;</span>Free f a<span class="br0">&#41;</span><span class="br0">&#41;</span></pre></div></div>
<p>You may assume that <code>f</code> has a <code>Functor</code> instance.  This is known as the <i>free monad</i> built from the functor <code>f</code>.
</p>
</li>
</ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Intuition_3">5.3 Intuition</span></h2>
<p>Let’s look more closely at the type of <code>(&gt;&gt;=)</code>. The basic intuition is that it combines two computations into one larger computation. The first argument, <code>m a</code>, is the first computation. However, it would be boring if the second argument were just an <code>m b</code>; then there would be no way for the computations to interact with one another (actually, this is exactly the situation with <code>Applicative</code>). So, the second argument to <code>(&gt;&gt;=)</code> has type <code>a -&gt; m b</code>: a function of this type, given a <i>result</i> of the first computation, can produce a second computation to be run. In other words, <code>x &gt;&gt;= k</code> is a computation which runs <code>x</code>, and then uses the result(s) of <code>x</code> to <i>decide</i> what computation to run second, using the output of the second computation as the result of the entire computation.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Actually, because Haskell allows general recursion, this is a lie: using a Haskell parsing library one can recursively construct <i>infinite</i> grammars, and hence <code>Applicative</code> (together with <code>Alternative</code>) is enough to parse any context-sensitive language with a finite alphabet. See <a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/2012/01/05/parsing-context-sensitive-languages-with-applicative/">Parsing context-sensitive languages with Applicative</a>.</span>
Intuitively, it is this ability to use the output from previous computations to decide what computations to run next that makes <code>Monad</code> more powerful than <code>Applicative</code>. The structure of an <code>Applicative</code> computation is fixed, whereas the structure of a <code>Monad</code> computation can change based on intermediate results.  This also means that parsers built using an <code>Applicative</code> interface can only parse context-free languages; in order to parse context-sensitive languages a <code>Monad</code> interface is needed.<span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>
</p><p>To see the increased power of <code>Monad</code> from a different point of view, let’s see what happens if we try to implement <code>(&gt;&gt;=)</code> in terms of <code>fmap</code>, <code>pure</code>, and <code>(&lt;*&gt;)</code>. We are given a value <code>x</code> of type <code>m a</code>, and a function <code>k</code> of type <code>a -&gt; m b</code>, so the only thing we can do is apply <code>k</code> to <code>x</code>. We can’t apply it directly, of course; we have to use <code>fmap</code> to lift it over the <code>m</code>. But what is the type of <code>fmap k</code>? Well, it’s <code>m a -&gt; m (m b)</code>. So after we apply it to <code>x</code>, we are left with something of type <code>m (m b)</code>—but now we are stuck; what we really want is an <code>m b</code>, but there’s no way to get there from here. We can <i>add</i> <code>m</code>’s using <code>pure</code>, but we have no way to <i>collapse</i> multiple <code>m</code>’s into one.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ You might hear some people claim that that the definition in terms of <code>return</code>, <code>fmap</code>, and <code>join</code> is the “math definition” and the definition in terms of <code>return</code> and <code>(&gt;&gt;=)</code> is something specific to Haskell. In fact, both definitions were known in the mathematics community long before Haskell picked up monads.</span>
</p><p>This ability to collapse multiple <code>m</code>’s is exactly the ability provided by the function <code>join&#160;:: m (m a) -&gt; m a</code>, and it should come as no surprise that an alternative definition of <code>Monad</code> can be given in terms of <code>join</code>:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Applicative m <span class="sy0">=&gt;</span> <span class="kw4">Monad</span>'' m <span class="kw1">where</span>
  join <span class="sy0">::</span> m <span class="br0">&#40;</span>m a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> m a</pre></div></div>
<p>In fact, the canonical definition of monads in category theory is in terms of <code>return</code>, <code>fmap</code>, and <code>join</code> (often called <span class="texhtml" dir="ltr">&#951;</span>, <span class="texhtml" dir="ltr"><i>T</i></span>, and <span class="texhtml" dir="ltr">&#956;</span> in the mathematical literature). Haskell uses an alternative formulation with <code>(&gt;&gt;=)</code> instead of <code>join</code> since it is more convenient to use <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>. However, sometimes it can be easier to think about <code>Monad</code> instances in terms of <code>join</code>, since it is a more “atomic” operation. (For example, <code>join</code> for the list monad is just <code>concat</code>.)
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> Implement <code>(&gt;&gt;=)</code> in terms of <code>fmap</code> (or <code>liftM</code>) and <code>join</code>.
</li><li> Now implement <code>join</code> and <code>fmap</code> (<code>liftM</code>) in terms of <code>(&gt;&gt;=)</code> and <code>return</code>.
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Utility_functions">5.4 Utility functions</span></h2>
<p>The <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html"><code>Control.Monad</code></a> module provides a large number of convenient utility functions, all of which can be implemented in terms of the basic <code>Monad</code> operations (<code>return</code> and <code>(&gt;&gt;=)</code> in particular).  We have already seen one of them, namely, <code>join</code>.  We also mention some other noteworthy ones here; implementing these utility functions oneself is a good exercise.  For a more detailed guide to these functions, with commentary and example code, see Henk-Jan van Tuyl’s <a rel="nofollow" class="external text" href="http://members.chello.nl/hjgtuyl/tourdemonad.html">tour</a>.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ This will most likely change in Haskell 2014 with the implementation of the <a href="/haskellwiki/Functor-Applicative-Monad_Proposal" title="Functor-Applicative-Monad Proposal">Haskell 2014 Applicative =&gt; Monad proposal</a>.</span>
</p>
<ul><li> <code>liftM&#160;:: Monad m =&gt; (a -&gt; b) -&gt; m a -&gt; m b</code>.  This should be familiar; of course, it is just <code>fmap</code>.  The fact that we have both <code>fmap</code> and <code>liftM</code> is an unfortunate consequence of the fact that the <code>Monad</code> type class does not require a <code>Functor</code> instance, even though mathematically speaking, every monad is a functor.  However, <code>fmap</code> and <code>liftM</code> are essentially interchangeable, since it is a bug (in a social rather than technical sense) for any type to be an instance of <code>Monad</code> without also being an instance of <code>Functor</code> <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.
</li></ul>
<ul><li> <code>ap&#160;:: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b</code> should also be familiar: it is equivalent to <code>(&lt;*&gt;)</code>, justifying the claim that the <code>Monad</code> interface is strictly more powerful than <code>Applicative</code>. We can make any <code>Monad</code> into an instance of <code>Applicative</code> by setting <code>pure = return</code> and <code>(&lt;*&gt;) = ap</code>.
</li></ul>
<ul><li> <code>sequence&#160;:: Monad m =&gt; [m a] -&gt; m [a]</code> takes a list of computations and combines them into one computation which collects a list of their results.  It is again something of a historical accident that <code>sequence</code> has a <code>Monad</code> constraint, since it can actually be implemented only in terms of <code>Applicative</code>.  There is an additional generalization of <code>sequence</code> to structures other than lists, which will be discussed in the <a href="#Traversable">section on <code>Traversable</code></a>.
</li></ul>
<ul><li> <code>replicateM&#160;:: Monad m =&gt; Int -&gt; m a -&gt; m [a]</code> is simply a combination of <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:replicate"><code>replicate</code></a> and <code>sequence</code>.
</li></ul>
<ul><li> <code>when&#160;:: Monad m =&gt; Bool -&gt; m () -&gt; m ()</code> conditionally executes a computation, evaluating to its second argument if the test is <code>True</code>, and to <code>return ()</code> if the test is <code>False</code>.  A collection of other sorts of monadic conditionals can be found in the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/IfElse"><code>IfElse</code> package</a>.
</li></ul>
<ul><li> <code>mapM&#160;:: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</code> maps its first argument over the second, and <code>sequence</code>s the results. The <code>forM</code> function is just <code>mapM</code> with its arguments reversed; it is called <code>forM</code> since it models generalized <code>for</code> loops: the list <code>[a]</code> provides the loop indices, and the function <code>a -&gt; m b</code> specifies the “body” of the loop for each index.
</li></ul>
<ul><li> <code>(=&lt;&lt;)&#160;:: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</code> is just <code>(&gt;&gt;=)</code> with its arguments reversed; sometimes this direction is more convenient since it corresponds more closely to function application.
</li></ul>
<ul><li> <code>(&gt;=&gt;)&#160;:: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c</code> is sort of like function composition, but with an extra <code>m</code> on the result type of each function, and the arguments swapped. We’ll have more to say about this operation later. There is also a flipped variant, <code>(&lt;=&lt;)</code>.
</li></ul>
<ul><li> The <code>guard</code> function is for use with instances of <code>MonadPlus</code>, which is discussed at the end of the <a href="#Monoid"><code>Monoid</code> section</a>.
</li></ul>
<p>Many of these functions also have “underscored” variants, such as <code>sequence_</code> and <code>mapM_</code>; these variants throw away the results of the computations passed to them as arguments, using them only for their side effects.
</p><p>Other monadic functions which are occasionally useful include <code>filterM</code>, <code>zipWithM</code>, <code>foldM</code>, and <code>forever</code>.
</p>
<h2> <span class="mw-headline" id="Laws_3">5.5 Laws</span></h2>
<p>There are several laws that instances of <code>Monad</code> should satisfy (see also the <a href="/haskellwiki/Monad_laws" title="Monad laws">Monad laws</a> wiki page). The standard presentation is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw3">return</span> a <span class="sy0">&gt;&gt;=</span> k  <span class="sy0">=</span>  k a
m <span class="sy0">&gt;&gt;=</span> <span class="kw3">return</span>    <span class="sy0">=</span>  m
m <span class="sy0">&gt;&gt;=</span> <span class="br0">&#40;</span>\x <span class="sy0">-&gt;</span> k x <span class="sy0">&gt;&gt;=</span> h<span class="br0">&#41;</span>  <span class="sy0">=</span>  <span class="br0">&#40;</span>m <span class="sy0">&gt;&gt;=</span> k<span class="br0">&#41;</span> <span class="sy0">&gt;&gt;=</span> h
&#160;
<span class="kw3">fmap</span> f xs  <span class="sy0">=</span>  xs <span class="sy0">&gt;&gt;=</span> <span class="kw3">return</span> <span class="sy0">.</span> f  <span class="sy0">=</span>  liftM f xs</pre></div></div>
<p>The first and second laws express the fact that <code>return</code> behaves nicely: if we inject a value <code>a</code> into a monadic context with <code>return</code>, and then bind to <code>k</code>, it is the same as just applying <code>k</code> to <code>a</code> in the first place; if we bind a computation <code>m</code> to <code>return</code>, nothing changes. The third law essentially says that <code>(&gt;&gt;=)</code> is associative, sort of.  The last law ensures that <code>fmap</code> and <code>liftM</code> are the same for types which are instances of both <code>Functor</code> and <code>Monad</code>—which, as already noted, should be every instance of <code>Monad</code>.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ I like to pronounce this operator “fish”.</span>
</p><p>However, the presentation of the above laws, especially the third, is marred by the asymmetry of <code>(&gt;&gt;=)</code>.  It’s hard to look at the laws and see what they’re really saying. I prefer a much more elegant version of the laws, which is formulated in terms of <code>(&gt;=&gt;)</code> <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>. Recall that <code>(&gt;=&gt;)</code> “composes” two functions of type <code>a -&gt; m b</code> and <code>b -&gt; m c</code>.  You can think of something of type <code>a -&gt; m b</code> (roughly) as a function from <code>a</code> to <code>b</code> which may also have some sort of effect in the context corresponding to <code>m</code>. <code>(&gt;=&gt;)</code> lets us compose these “effectful functions”, and we would like to know what properties <code>(&gt;=&gt;)</code> has.  The monad laws reformulated in terms of <code>(&gt;=&gt;)</code> are:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw3">return</span> <span class="sy0">&gt;=&gt;</span> g  <span class="sy0">=</span>  g
g <span class="sy0">&gt;=&gt;</span> <span class="kw3">return</span>  <span class="sy0">=</span>  g
<span class="br0">&#40;</span>g <span class="sy0">&gt;=&gt;</span> h<span class="br0">&#41;</span> <span class="sy0">&gt;=&gt;</span> k  <span class="sy0">=</span>  g <span class="sy0">&gt;=&gt;</span> <span class="br0">&#40;</span>h <span class="sy0">&gt;=&gt;</span> k<span class="br0">&#41;</span></pre></div></div>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ As fans of category theory will note, these laws say precisely that functions of type <code>a -&gt; m b</code> are the arrows of a category with <code>(&gt;=&gt;)</code> as composition!  Indeed, this is known as the <i>Kleisli category</i> of the monad <code>m</code>.  It will come up again when we discuss <code>Arrow</code>s.</span>
</p><p>Ah, much better!  The laws simply state that <code>return</code> is the identity of <code>(&gt;=&gt;)</code>, and that <code>(&gt;=&gt;)</code> is associative <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.
</p><p>There is also a formulation of the monad laws in terms of <code>fmap</code>, <code>return</code>, and <code>join</code>; for a discussion of this formulation, see the Haskell <a rel="nofollow" class="external text" href="http://en.wikibooks.org/wiki/Haskell/Category_theory">wikibook page on category theory</a>.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> Given the definition <code>g &gt;=&gt; h = \x -&gt; g x &gt;&gt;= h</code>, prove the equivalence of the above laws and the usual monad laws.
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="do_notation">5.6 <code>do</code> notation</span></h2>
<p>Haskell’s special <code>do</code> notation supports an “imperative style” of programming by providing syntactic sugar for chains of monadic expressions.  The genesis of the notation lies in realizing that something like <code>a &gt;&gt;= \x -&gt; b &gt;&gt; c &gt;&gt;= \y -&gt; d </code> can be more readably written by putting successive computations on separate lines:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">a <span class="sy0">&gt;&gt;=</span> \x <span class="sy0">-&gt;</span>
b <span class="sy0">&gt;&gt;</span>
c <span class="sy0">&gt;&gt;=</span> \y <span class="sy0">-&gt;</span>
d</pre></div></div>
<p>This emphasizes that the overall computation consists of four computations <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>, and that <code>x</code> is bound to the result of <code>a</code>, and <code>y</code> is bound to the result of <code>c</code> (<code>b</code>, <code>c</code>, and <code>d</code> are allowed to refer to <code>x</code>, and <code>d</code> is allowed to refer to <code>y</code> as well).  From here it is not hard to imagine a nicer notation:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">do</span> <span class="br0">&#123;</span> x <span class="sy0">&lt;-</span> a
  &#160;;      b
  &#160;; y <span class="sy0">&lt;-</span> c
  &#160;;      d
   <span class="br0">&#125;</span></pre></div></div>
<p>(The curly braces and semicolons may optionally be omitted; the Haskell parser uses layout to determine where they should be inserted.)  This discussion should make clear that <code>do</code> notation is just syntactic sugar.  In fact, <code>do</code> blocks are recursively translated into monad operations (almost) like this:
</p>
<pre>
                  do e → e
       do { e; stmts } → e &gt;&gt; do { stmts }
  do { v &lt;- e; stmts } → e &gt;&gt;= \v -&gt; do { stmts }
do { let decls; stmts} → let decls in do { stmts }
</pre>
<p>This is not quite the whole story, since <code>v</code> might be a pattern instead of a variable.  For example, one can write
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">do</span> <span class="br0">&#40;</span>x:xs<span class="br0">&#41;</span> <span class="sy0">&lt;-</span> foo
   bar x</pre></div></div>
<p>but what happens if <code>foo</code> produces an empty list?  Well, remember that ugly <code>fail</code> function in the <code>Monad</code> type class declaration?  That’s what happens.  See <a rel="nofollow" class="external text" href="http://www.haskell.org/onlinereport/exps.html#sect3.14">section 3.14 of the Haskell Report</a> for the full details. See also the discussion of <code>MonadPlus</code> and <code>MonadZero</code> in the <a href="#Other_monoidal_classes:_Alternative.2C_MonadPlus.2C_ArrowPlus">section on other monoidal classes</a>.
</p><p>A final note on intuition: <code>do</code> notation plays very strongly to the “computational context” point of view rather than the “container” point of view, since the binding notation <code>x &lt;- m</code> is suggestive of “extracting” a single <code>x</code> from <code>m</code> and doing something with it.  But <code>m</code> may represent some sort of a container, such as a list or a tree; the meaning of <code>x &lt;- m</code> is entirely dependent on the implementation of <code>(&gt;&gt;=)</code>.  For example, if <code>m</code> is a list, <code>x &lt;- m</code> actually means that <code>x</code> will take on each value from the list in turn.
</p>
<h2> <span class="mw-headline" id="Further_reading_3">5.7 Further reading</span></h2>
<p>Philip Wadler was the first to propose using monads to structure functional programs.  <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/topics/monads.html">His paper</a> is still a readable introduction to the subject.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ <a href="/haskellwiki/All_About_Monads" title="All About Monads">All About Monads</a>,
<a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/Monads_as_Containers">Monads as containers</a>,
<a rel="nofollow" class="external text" href="http://en.wikibooks.org/w/index.php?title=Haskell/Understanding_monads">Understanding monads</a>,
<a href="/haskellwiki/The_Monadic_Way" title="The Monadic Way">The Monadic Way</a>,
<a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You Could Have Invented Monads! (And Maybe You Already Have.)</a>,
<a rel="nofollow" class="external text" href="http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html">there’s a monster in my Haskell!</a>,
<a rel="nofollow" class="external text" href="http://kawagner.blogspot.com/2007/02/understanding-monads-for-real.html">Understanding Monads. For real.</a>,
<a rel="nofollow" class="external text" href="http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes">Monads in 15 minutes: Backtracking and Maybe</a>,
<a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/Monads_as_computation">Monads as computation</a>,
<a rel="nofollow" class="external text" href="http://metafoo.co.uk/practical-monads.txt">Practical Monads</a></span>
</p><p>There are, of course, numerous monad tutorials of varying quality <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.
</p><p>A few of the best include Cale Gibbard’s <a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/Monads_as_Containers">Monads as containers</a> and <a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/Monads_as_computation">Monads as computation</a>; Jeff Newbern’s <a href="/haskellwiki/All_About_Monads" title="All About Monads">All About Monads</a>, a comprehensive guide with lots of examples; and Dan Piponi’s <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You Could Have Invented Monads!</a>, which features great exercises.  If you just want to know how to use <code>IO</code>, you could consult the <a href="/haskellwiki/Introduction_to_IO" title="Introduction to IO">Introduction to IO</a>. Even this is just a sampling; the <a href="/haskellwiki/Monad_tutorials_timeline" title="Monad tutorials timeline">monad tutorials timeline</a> is a more complete list. (All these monad tutorials have prompted parodies like <a rel="nofollow" class="external text" href="http://koweycode.blogspot.com/2007/01/think-of-monad.html">think of a monad ...</a> as well as other kinds of backlash like <a rel="nofollow" class="external text" href="http://ahamsandwich.wordpress.com/2007/07/26/monads-and-why-monad-tutorials-are-all-awful/">Monads! (and Why Monad Tutorials Are All Awful)</a> or <a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/">Abstraction, intuition, and the “monad tutorial fallacy”</a>.)
</p><p>Other good monad references which are not necessarily tutorials include <a rel="nofollow" class="external text" href="http://members.chello.nl/hjgtuyl/tourdemonad.html">Henk-Jan van Tuyl’s tour</a> of the functions in <code>Control.Monad</code>, Dan Piponi’s <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2006/10/monads-field-guide.html">field guide</a>, Tim Newsham’s <a rel="nofollow" class="external text" href="http://www.thenewsh.com/~newsham/haskell/monad.html">What’s a Monad?</a>, and Chris Smith's excellent article <a rel="nofollow" class="external text" href="http://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/">Why Do Monads Matter?</a>. There are also many blog posts which have been written on various aspects of monads; a collection of links can be found under <a href="/haskellwiki/Blog_articles/Monads" title="Blog articles/Monads">Blog articles/Monads</a>.
</p><p>For help constructing monads from scratch, and for obtaining a "deep embedding" of monad operations suitable for use in, say, compiling a domain-specific language, see <a rel="nofollow" class="external text" href="http://projects.haskell.org/operational">Apfelmus's operational package</a>.
</p><p>One of the quirks of the <code>Monad</code> class and the Haskell type system is that it is not possible to straightforwardly declare <code>Monad</code> instances for types which require a class constraint on their data, even if they are monads from a mathematical point of view. For example, <code>Data.Set</code> requires an <code>Ord</code> constraint on its data, so it cannot be easily made an instance of <code>Monad</code>.  A solution to this problem was <a rel="nofollow" class="external text" href="http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros">first described by Eric Kidd</a>, and later made into a <a rel="nofollow" class="external text" href="http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad">library named rmonad</a> by Ganesh Sittampalam and Peter Gavin.
</p><p>There are many good reasons for eschewing <code>do</code> notation; some have gone so far as to <a href="/haskellwiki/Do_notation_considered_harmful" title="Do notation considered harmful">consider it harmful</a>.
</p><p>Monads can be generalized in various ways; for an exposition of one possibility, see Robert Atkey’s paper on <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/ratkey/paramnotions-jfp.pdf">parameterized monads</a>, or Dan Piponi’s <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2009/02/beyond-monads.html">Beyond Monads</a>.
</p><p>For the categorically inclined, monads can be viewed as monoids (<a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html">From Monoids to Monads</a>) and also as closure operators <a rel="nofollow" class="external text" href="http://blog.plover.com/math/monad-closure.html">Triples and Closure</a>.  Derek Elkins’s article in <a rel="nofollow" class="external text" href="http://www.haskell.org/wikiupload/8/85/TMR-Issue13.pdf">issue 13 of the Monad.Reader</a> contains an exposition of the category-theoretic underpinnings of some of the standard <code>Monad</code> instances, such as <code>State</code> and <code>Cont</code>.  Jonathan Hill and Keith Clarke have <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.6497">an early paper explaining the connection between monads as they arise in category theory and as used in functional programming</a>.  There is also a <a rel="nofollow" class="external text" href="http://okmij.org/ftp/Computation/IO-monad-history.html">web page by Oleg Kiselyov</a> explaining the history of the IO monad.
</p><p>Links to many more research papers related to monads can be found under <a href="/haskellwiki/Research_papers/Monads_and_arrows" title="Research papers/Monads and arrows">Research papers/Monads and arrows</a>.
</p>
<h1> <span class="mw-headline" id="Monad_transformers">6 Monad transformers</span></h1>
<p>One would often like to be able to combine two monads into one: for example, to have stateful, nondeterministic computations (<code>State</code> + <code>[]</code>), or computations which may fail and can consult a read-only environment (<code>Maybe</code> + <code>Reader</code>), and so on.  Unfortunately, monads do not compose as nicely as applicative functors (yet another reason to use <code>Applicative</code> if you don’t need the full power that <code>Monad</code> provides), but some monads can be combined in certain ways.
</p>
<h2> <span class="mw-headline" id="Standard_monad_transformers">6.1 Standard monad transformers</span></h2>
<p>The <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/transformers">transformers</a> library provides a number of standard <i>monad transformers</i>. Each monad transformer adds a particular capability/feature/effect to any existing monad.
</p>
<ul><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Identity.html"><code>IdentityT</code></a> is the identity transformer, which maps a monad to (something isomorphic to) itself.  This may seem useless at first glance, but it is useful for the same reason that the <code>id</code> function is useful -- it can be passed as an argument to things which are parameterized over an arbitrary monad transformer, when you do not actually want any extra capabilities.
</li><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State.html"><code>StateT</code></a> adds a read-write state.
</li><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Reader.html"><code>ReaderT</code></a> adds a read-only environment.
</li><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Writer.html"><code>WriterT</code></a> adds a write-only log.
</li><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-Trans-RWS.html"><code>RWST</code></a> conveniently combines <code>ReaderT</code>, <code>WriterT</code>, and <code>StateT</code> into one.
</li><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Maybe.html"><code>MaybeT</code></a> adds the possibility of failure.
</li><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Error.html"><code>ErrorT</code></a> adds the possibility of failure with an arbitrary type to represent errors.
</li><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-List.html"><code>ListT</code></a> adds non-determinism (however, see the discussion of <code>ListT</code> below).
</li><li> <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Cont.html"><code>ContT</code></a> adds continuation handling.
</li></ul>
<p>For example, <code>StateT s Maybe</code> is an instance of <code>Monad</code>; computations of type <code>StateT s Maybe a</code> may fail, and have access to a mutable state of type <code>s</code>.  Monad transformers can be multiply stacked.  One thing to keep in mind while using monad transformers is that the order of composition matters.  For example, when a <code>StateT s Maybe a</code> computation fails, the state ceases being updated (indeed, it simply disappears); on the other hand, the state of a <code>MaybeT (State s) a</code> computation may continue to be modified even after the computation has "failed". This may seem backwards, but it is correct. Monad transformers build composite monads “inside out”; <code>MaybeT (State s) a</code> is isomorphic to <code>s -&gt; (Maybe a, s)</code>.  (Lambdabot has an indispensable <code>@unmtl</code> command which you can use to “unpack” a monad transformer stack in this way.)
Intuitively, the monads become "more fundamental" the further inside the stack you get, and the effects of inner monads "have precedence" over the effects of outer ones.  Of course, this is just handwaving, and if you are unsure of the proper order for some monads you wish to combine, there is no substitute for using <code>@unmtl</code> or simply trying out the various options.
</p>
<h2> <span class="mw-headline" id="Definition_and_laws">6.2 Definition and laws</span></h2>
<p>All monad transformers should implement the <code>MonadTrans</code> type class, defined in <code>Control.Monad.Trans.Class</code>:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> MonadTrans t <span class="kw1">where</span>
  lift <span class="sy0">::</span> <span class="kw4">Monad</span> m <span class="sy0">=&gt;</span> m a <span class="sy0">-&gt;</span> t m a</pre></div></div>
<p>It allows arbitrary computations in the base monad <code>m</code> to be “lifted” into computations in the transformed monad <code>t m</code>. (Note that type application associates to the left, just like function application, so <code>t m a = (t m) a</code>.)
</p><p><code>lift</code> must satisfy the laws
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">lift <span class="sy0">.</span> <span class="kw3">return</span>   <span class="sy0">=</span>  <span class="kw3">return</span>
lift <span class="br0">&#40;</span>m <span class="sy0">&gt;&gt;=</span> f<span class="br0">&#41;</span>  <span class="sy0">=</span>  lift m <span class="sy0">&gt;&gt;=</span> <span class="br0">&#40;</span>lift <span class="sy0">.</span> f<span class="br0">&#41;</span></pre></div></div>
<p>which intuitively state that <code>lift</code> transforms <code>m a</code> computations into <code>t m a</code> computations in a "sensible" way, which sends the <code>return</code> and <code>(&gt;&gt;=)</code> of <code>m</code> to the <code>return</code> and <code>(&gt;&gt;=)</code> of <code>t m</code>.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> What is the kind of <code>t</code> in the declaration of <code>MonadTrans</code>?
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Transformer_type_classes_and_.22capability.22_style">6.3 Transformer type classes and "capability" style</span></h2>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ The only problem with this scheme is the quadratic number of instances required as the number of standard monad transformers grows—but as the current set of standard monad transformers seems adequate for most common use cases, this may not be that big of a deal.</span>
</p><p>There are also type classes (provided by the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/mtl"><code>mtl</code> package</a>) for the operations of each transformer.  For example, the <code>MonadState</code> type class provides the state-specific methods <code>get</code> and <code>put</code>, allowing you to conveniently use these methods not only with <code>State</code>, but with any monad which is an instance of <code>MonadState</code>—including <code>MaybeT (State s)</code>, <code>StateT s (ReaderT r IO)</code>, and so on. Similar type classes exist for <code>Reader</code>, <code>Writer</code>, <code>Cont</code>, <code>IO</code>, and others <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.
</p><p>These type classes serve two purposes.  First, they get rid of (most of) the need for explicitly using <code>lift</code>, giving a type-directed way to automatically determine the right number of calls to <code>lift</code>. Simply writing <code>put</code> will be automatically translated into <code>lift . put</code>, <code>lift . lift . put</code>, or something similar depending on what concrete monad stack you are using.
</p><p>Second, they give you more flexibility to switch between different concrete monad stacks.  For example, if you are writing a state-based algorithm, don't write
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">foo <span class="sy0">::</span> State <span class="kw4">Int</span> <span class="kw4">Char</span>
foo <span class="sy0">=</span> modify <span class="br0">&#40;</span><span class="sy0">*</span>2<span class="br0">&#41;</span> <span class="sy0">&gt;&gt;</span> <span class="kw3">return</span> 'x'</pre></div></div>
<p>but rather
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">foo <span class="sy0">::</span> MonadState <span class="kw4">Int</span> m <span class="sy0">=&gt;</span> m <span class="kw4">Char</span>
foo <span class="sy0">=</span> modify <span class="br0">&#40;</span><span class="sy0">*</span>2<span class="br0">&#41;</span> <span class="sy0">&gt;&gt;</span> <span class="kw3">return</span> 'x'</pre></div></div>
<p>Now, if somewhere down the line you realize you need to introduce the possibility of failure, you might switch from <code>State Int</code> to <code>MaybeT (State Int)</code>.  The type of the first version of <code>foo</code> would need to be modified to reflect this change, but the second version of <code>foo</code> can still be used as-is.
</p><p>However, this sort of "capability-based" style (<i>e.g.</i> specifying that <code>foo</code> works for any monad with the "state capability") quickly runs into problems when you try to naively scale it up: for example, what if you need to maintain two independent states?  A framework for solving this and related problems is described by Schrijvers and Olivera (<a rel="nofollow" class="external text" href="http://users.ugent.be/~tschrijv/Research/papers/icfp2011.pdf">Monads, zippers and views: virtualizing the monad stack, ICFP 2011</a>) and is implemented in the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/Monatron"><code>Monatron</code> package</a>.
</p>
<h2> <span class="mw-headline" id="Composing_monads">6.4 Composing monads</span></h2>
<p>Is the composition of two monads always a monad? As hinted previously, the answer is no.
</p><p>Since <code>Applicative</code> functors are closed under composition, the problem must lie with <code>join</code>.  Indeed, suppose <code>m</code> and <code>n</code> are arbitrary monads; to make a monad out of their composition we would need to be able to implement
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">join <span class="sy0">::</span> m <span class="br0">&#40;</span>n <span class="br0">&#40;</span>m <span class="br0">&#40;</span>n a<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">-&gt;</span> m <span class="br0">&#40;</span>n a<span class="br0">&#41;</span></pre></div></div>
<p>but it is not clear how this could be done in general.  The  <code>join</code> method for <code>m</code> is no help, because the two occurrences of <code>m</code> are not next to each other (and likewise for <code>n</code>).
</p><p>However, one situation in which it can be done is if <code>n</code> <i>distributes</i> over <code>m</code>, that is, if there is a function
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">distrib <span class="sy0">::</span> n <span class="br0">&#40;</span>m a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> m <span class="br0">&#40;</span>n a<span class="br0">&#41;</span></pre></div></div>
<p>satisfying certain laws. See Jones and Duponcheel (<a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.2605">Composing Monads</a>); see also the <a href="#Traversable">section on Traversable</a>.
</p><p>For a much more in-depth discussion and analysis of the failure of monads to be closed under composition, see <a rel="nofollow" class="external text" href="http://stackoverflow.com/questions/13034229/concrete-example-showing-that-monads-are-not-closed-under-composition-with-proo?lq=1">this question on StackOverflow</a>.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ul><li> Implement <code>join&#160;:: M (N (M (N a))) -&gt; M (N a)</code>, given <code>distrib&#160;:: N (M a) -&gt; M (N a)</code> and assuming <code>M</code> and <code>N</code> are instances of <code>Monad</code>.
</li></ul>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Further_reading_4">6.5 Further reading</span></h2>
<p>Much of the monad transformer library (originally <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/mtl"><code>mtl</code></a>, now split between <code>mtl</code> and <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/transformers"><code>transformers</code></a>), including the <code>Reader</code>, <code>Writer</code>, <code>State</code>, and other monads, as well as the monad transformer framework itself, was inspired by Mark Jones’s classic paper <a rel="nofollow" class="external text" href="http://web.cecs.pdx.edu/~mpj/pubs/springschool.html">Functional Programming with Overloading and Higher-Order Polymorphism</a>. It’s still very much worth a read—and highly readable—after almost fifteen years.
</p><p>See <a rel="nofollow" class="external text" href="http://article.gmane.org/gmane.comp.lang.haskell.libraries/17139">Edward Kmett's mailing list message</a> for a description of the history and relationships among monad transformer packages (<code>mtl</code>, <code>transformers</code>, <code>monads-fd</code>, <code>monads-tf</code>).
</p><p>There are two excellent references on monad transformers. Martin Grabmüller’s <a rel="nofollow" class="external text" href="http://www.grabmueller.de/martin/www/pub/Transformers.en.html">Monad Transformers Step by Step</a> is a thorough description, with running examples, of how to use monad transformers to elegantly build up computations with various effects.  <a rel="nofollow" class="external text" href="http://cale.yi.org/index.php/How_To_Use_Monad_Transformers">Cale Gibbard’s article</a> on how to use monad transformers is more practical, describing how to structure code using monad transformers to make writing it as painless as possible.  Another good starting place for learning about monad transformers is a <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2006/05/grok-haskell-monad-transformers.html">blog post by Dan Piponi</a>.
</p><p>The <code>ListT</code> transformer from the <code>transformers</code> package comes with the caveat that <code>ListT m</code> is only a monad when <code>m</code> is <i>commutative</i>, that is, when <code>ma &gt;&gt;= \a -&gt; mb &gt;&gt;= \b -&gt; foo</code> is equivalent to <code>mb &gt;&gt;= \b -&gt; ma &gt;&gt;= \a -&gt; foo</code> (i.e. the order of <code>m</code>'s effects does not matter).  For one explanation why, see  Dan Piponi's blog post <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2006/11/why-isnt-listt-monad.html">"Why isn't <code>ListT []</code> a monad"</a>.  For more examples, as well as a design for a version of <code>ListT</code> which does not have this problem, see <a rel="nofollow" class="external text" href="http://www.haskell.org/haskellwiki/ListT_done_right"><code>ListT</code> done right</a>.
</p><p>There is an alternative way to compose monads, using coproducts, as described by <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.8.3581">Lüth and Ghani</a>.  This method is interesting but has not (yet?) seen widespread use.  For a more recent alternative, see Kiselyov et al's <a rel="nofollow" class="external text" href="http://okmij.org/ftp/Haskell/extensible/exteff.pdf">Extensible Effects: An Alternative to Monad Transformers</a>.
</p>
<h1> <span class="mw-headline" id="MonadFix">7 MonadFix</span></h1>
<p><i>Note: <code>MonadFix</code> is included here for completeness (and because it is interesting) but seems not to be used much.  Skipping this section on a first read-through is perfectly OK (and perhaps even recommended).</i>
</p>
<h2> <span class="mw-headline" id="mdo.2Fdo_rec_notation">7.1 <code>mdo</code>/<code>do rec</code> notation</span></h2>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ In GHC 7.6, the flag has been changed to <code>-XRecursiveDo</code>.</span>
The <code>MonadFix</code> class describes monads which support the special fixpoint operation <code>mfix&#160;:: (a -&gt; m a) -&gt; m a</code>, which allows the output of monadic computations to be defined via (effectful) recursion.  This is <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation">supported in GHC</a> by a special “recursive do” notation, enabled by the <code>-XDoRec</code> flag<span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.  Within a <code>do</code> block, one may have a nested <code>rec</code> block, like so:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">do</span> <span class="br0">&#123;</span> x <span class="sy0">&lt;-</span> foo
  &#160;; rec <span class="br0">&#123;</span> y <span class="sy0">&lt;-</span> baz
        &#160;; z <span class="sy0">&lt;-</span> bar
        &#160;;      bob
         <span class="br0">&#125;</span>
  &#160;; w <span class="sy0">&lt;-</span> frob
   <span class="br0">&#125;</span></pre></div></div>
<p>Normally (if we had <code>do</code> in place of <code>rec</code> in the above example), <code>y</code> would be in scope in <code>bar</code> and <code>bob</code> but not in <code>baz</code>, and <code>z</code> would be in scope only in <code>bob</code>.  With the <code>rec</code>, however, <code>y</code> and <code>z</code> are both in scope in all three of <code>baz</code>, <code>bar</code>, and <code>bob</code>. A <code>rec</code> block is analogous to a <code>let</code> block such as
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">let</span> <span class="br0">&#123;</span> y <span class="sy0">=</span> baz
   &#160;; z <span class="sy0">=</span> bar
    <span class="br0">&#125;</span>
<span class="kw1">in</span> bob</pre></div></div>
<p>because, in Haskell, every variable bound in a <code>let</code>-block is in scope throughout the entire block.  (From this point of view, Haskell's normal <code>do</code> blocks are analogous to Scheme's <code>let*</code> construct.)
</p><p>What could such a feature be used for?  One of the motivating examples given in the original paper describing <code>MonadFix</code> (see below) is encoding circuit descriptions.  A line in a <code>do</code>-block such as 
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  x <span class="sy0">&lt;-</span> gate y z</pre></div></div>
<p>describes a gate whose input wires are labeled <code>y</code> and <code>z</code> and whose output wire is labeled <code>x</code>.  Many (most?) useful circuits, however, involve some sort of feedback loop, making them impossible to write in a normal <code>do</code>-block (since some wire would have to be mentioned as an input <i>before</i> being listed as an output).  Using a <code>rec</code> block solves this problem.
</p>
<h2> <span class="mw-headline" id="Examples_and_intuition">7.2 Examples and intuition</span></h2>
<p>Of course, not every monad supports such recursive binding.  However, as mentioned above, it suffices to have an implementation of <code>mfix&#160;:: (a -&gt; m a) -&gt; m a</code>, satisfying a few laws.  Let's try implementing <code>mfix</code> for the <code>Maybe</code> monad.  That is, we want to implement a function
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">maybeFix <span class="sy0">::</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> a</pre></div></div>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Actually, <code>fix</code> is implemented slightly differently for efficiency reasons; but the given definition is equivalent and simpler for the present purpose.</span>
Let's think for a moment about the implementation <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span> of the non-monadic <code>fix&#160;:: (a -&gt; a) -&gt; a</code>:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">fix f <span class="sy0">=</span> f <span class="br0">&#40;</span>fix f<span class="br0">&#41;</span></pre></div></div>
<p>Inspired by <code>fix</code>, our first attempt at implementing <code>maybeFix</code> might be something like
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">maybeFix <span class="sy0">::</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> a
maybeFix f <span class="sy0">=</span> maybeFix f <span class="sy0">&gt;&gt;=</span> f</pre></div></div>
<p>This has the right type.  However, something seems wrong: there is nothing in particular here about <code>Maybe</code>; <code>maybeFix</code> actually has the more general type <code>Monad m =&gt; (a -&gt; m a) -&gt; m a</code>.  But didn't we just say that not all monads support <code>mfix</code>?
</p><p>The answer is that although this implementation of <code>maybeFix</code> has the right type, it does <i>not</i> have the intended semantics.  If we think about how <code>(&gt;&gt;=)</code> works for the <code>Maybe</code> monad (by pattern-matching on its first argument to see whether it is <code>Nothing</code> or <code>Just</code>) we can see that this definition of <code>maybeFix</code> is completely useless: it will just recurse infinitely, trying to decide whether it is going to return <code>Nothing</code> or <code>Just</code>, without ever even so much as a glance in the direction of <code>f</code>.
</p><p>The trick is to simply <i>assume</i> that <code>maybeFix</code> will return <code>Just</code>, and get on with life!
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">maybeFix <span class="sy0">::</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="kw4">Maybe</span> a
maybeFix f <span class="sy0">=</span> ma
  <span class="kw1">where</span> ma <span class="sy0">=</span> f <span class="br0">&#40;</span>fromJust ma<span class="br0">&#41;</span></pre></div></div>
<p>This says that the result of <code>maybeFix</code> is <code>ma</code>, and assuming that <code>ma = Just x</code>, it is defined (recursively) to be equal to <code>f x</code>.
</p><p>Why is this OK?  Isn't <code>fromJust</code> almost as bad as <code>unsafePerformIO</code>?  Well, usually, yes.  This is just about the only situation in which it is justified!  The interesting thing to note is that <code>maybeFix</code> <i>will never crash</i> -- although it may, of course, fail to terminate.  The only way we could get a crash is if we try to evaluate <code>fromJust ma</code> when we know that <code>ma = Nothing</code>.  But how could we know <code>ma = Nothing</code>?  Since <code>ma</code> is defined as <code>f (fromJust ma)</code>, it must be that this expression has already been evaluated to <code>Nothing</code> -- in which case there is no reason for us to be evaluating <code>fromJust ma</code> in the first place!  
</p><p>To see this from another point of view, we can consider three possibilities. First, if <code>f</code> outputs <code>Nothing</code> without looking at its argument, then <code>maybeFix f</code> clearly returns <code>Nothing</code>.  Second, if <code>f</code> always outputs <code>Just x</code>, where <code>x</code> depends on its argument, then the recursion can proceed usefully: <code>fromJust ma</code> will be able to evaluate to <code>x</code>, thus feeding <code>f</code>'s output back to it as input.  Third, if <code>f</code> tries to use its argument to decide whether to output <code>Just</code> or <code>Nothing</code>, then <code>maybeFix f</code> will not terminate: evaluating <code>f</code>'s argument requires evaluating <code>ma</code> to see whether it is <code>Just</code>, which requires evaluating <code>f (fromJust ma)</code>, which requires evaluating <code>ma</code>, ... and so on.
</p><p>There are also instances of <code>MonadFix</code> for lists (which works analogously to the instance for <code>Maybe</code>), for <code>ST</code>, and for <code>IO</code>.  The <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#fixIO">instance for <code>IO</code></a> is particularly amusing: it creates a new (empty) <code>MVar</code>, immediately reads its contents using <code>unsafeInterleaveIO</code> (which delays the actual reading lazily until the value is needed), uses the contents of the <code>MVar</code> to compute a new value, which it then writes back into the <code>MVar</code>.  It almost seems, spookily, that <code>mfix</code> is sending a value back in time to itself through the <code>MVar</code> -- though of course what is really going on is that the reading is delayed just long enough (via <code>unsafeInterleaveIO</code>) to get the process bootstrapped.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ul><li> Implement a <code>MonadFix</code> instance for <code>[]</code>.
</li></ul>
</td>
</tr></table>
<h2> <span class="mw-headline" id="GHC_7.6_changes">7.3 GHC 7.6 changes</span></h2>
<p>GHC 7.6 reinstated the old <code>mdo</code> syntax, so the example at the start of this section can be written
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">mdo <span class="br0">&#123;</span> x <span class="sy0">&lt;-</span> foo
   &#160;; y <span class="sy0">&lt;-</span> baz
   &#160;; z <span class="sy0">&lt;-</span> bar
   &#160;;      bob
   &#160;; w <span class="sy0">&lt;-</span> frob
    <span class="br0">&#125;</span></pre></div></div>
<p>which will be translated into the original example (assuming that, say, <code>bar</code> and <code>bob</code> refer to <code>y</code>.  The difference is that <code>mdo</code> will analyze the code in order to find minimal recursive blocks, which will be placed in <code>rec</code> blocks, whereas <code>rec</code> blocks desugar directly into calls to <code>mfix</code> without any further analysis.  
</p>
<h2> <span class="mw-headline" id="Further_reading_5">7.4 Further reading</span></h2>
<p>For more information (such as the precise desugaring rules for <code>rec</code> blocks), see Levent Erkök and John Launchbury's 2002 Haskell workshop paper, <a rel="nofollow" class="external text" href="http://sites.google.com/site/leventerkok/recdo.pdf?attredirects=0">A Recursive do for Haskell</a>, or for full details, Levent Erkök’s thesis, <a rel="nofollow" class="external text" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.15.1543&amp;rep=rep1&amp;type=pdf">Value Recursion in Monadic Computations</a>.  (Note, while reading, that <code>MonadFix</code> used to be called <code>MonadRec</code>.)  You can also read the <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation">GHC user manual section on recursive do-notation</a>.
</p>
<h1> <span class="mw-headline" id="Semigroup">8 Semigroup</span></h1>
<p>A semigroup is a set <img class="tex" alt="S\ " src="/wikiupload/math/a/a/0/aa0919ffd628af51a8619bc522c022dc.png" /> together with a binary operation <img class="tex" alt="\oplus\ " src="/wikiupload/math/c/4/1/c41dc31ad3c3ed1daa811e9abdc275d2.png" /> which
combines elements from <img class="tex" alt="S\ " src="/wikiupload/math/a/a/0/aa0919ffd628af51a8619bc522c022dc.png" />. The <img class="tex" alt="\oplus\ " src="/wikiupload/math/c/4/1/c41dc31ad3c3ed1daa811e9abdc275d2.png" /> operator is required to be associative
(that is, <img class="tex" alt="(a \oplus b) \oplus c = a \oplus (b \oplus c)\ " src="/wikiupload/math/b/e/e/beed6e61f1ab6e962dd939a98daac80a.png" />, for any
<img class="tex" alt="a,b,c\ " src="/wikiupload/math/e/8/b/e8b1f334a55d5063f79d36ae27a13821.png" /> which are elements of <img class="tex" alt="S\ " src="/wikiupload/math/a/a/0/aa0919ffd628af51a8619bc522c022dc.png" />).
</p><p>For example, the natural numbers under addition form a semigroup: the sum of any two natural numbers is a natural number, and <img class="tex" alt="(a+b)+c = a+(b+c)\ " src="/wikiupload/math/0/9/a/09ae6797965d5de4ec63dbf5d3b496ae.png" /> for any natural numbers <img class="tex" alt="a\ " src="/wikiupload/math/9/9/c/99cdf5701ba5333a8a7668dd0fbc29bd.png" />, <img class="tex" alt="b\ " src="/wikiupload/math/5/6/0/560775887485101d093e4f17bd400222.png" />, and <img class="tex" alt="c\,\ " src="/wikiupload/math/f/4/f/f4f87e29b03176fb1296096528e80ce3.png" />. The integers under multiplication also form a semigroup, as do the integers (or rationals, or reals) under <img class="tex" alt="\max\ " src="/wikiupload/math/a/8/a/a8af727230b340e38de137347cc51bda.png" /> or <img class="tex" alt="\min\ " src="/wikiupload/math/e/4/6/e46fafd0ab259488899619a4a6b8fb76.png" />, Boolean values under conjunction and disjunction, lists under concatenation, functions from a set to itself under composition ... Semigroups show up all over the place, once you know to look for them.
</p>
<h2> <span class="mw-headline" id="Definition_4">8.1 Definition</span></h2>
<p>Semigroups are not (yet?) defined in the base package, but the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/semigroups">semigroups</a> package provides a standard definition.
</p><p>The definition of the <code>Semigroup</code> type class (<a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/semigroups/latest/doc/html/Data-Semigroup.html">haddock</a>) is as follows:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Semigroup a <span class="kw1">where</span>
  <span class="br0">&#40;</span><span class="sy0">&lt;&gt;</span><span class="br0">&#41;</span> <span class="sy0">::</span> a <span class="sy0">-&gt;</span> a <span class="sy0">-&gt;</span> a
&#160;
  sconcat <span class="sy0">::</span> NonEmpty a <span class="sy0">-&gt;</span> a
  sconcat <span class="sy0">=</span> sconcat <span class="br0">&#40;</span>a&#160;:<span class="sy0">|</span> <span class="kw1">as</span><span class="br0">&#41;</span> <span class="sy0">=</span> go a <span class="kw1">as</span> <span class="kw1">where</span>
    go b <span class="br0">&#40;</span>c:cs<span class="br0">&#41;</span> <span class="sy0">=</span> b <span class="sy0">&lt;&gt;</span> go c cs
    go b <span class="br0">&#91;</span><span class="br0">&#93;</span>     <span class="sy0">=</span> b
&#160;
  times1p <span class="sy0">::</span> Whole n <span class="sy0">=&gt;</span> n <span class="sy0">-&gt;</span> a <span class="sy0">-&gt;</span> a
  times1p <span class="sy0">=</span> <span class="sy0">...</span></pre></div></div>
<p>The really important method is <code>(&lt;&gt;)</code>, representing the associative binary operation.  The other two methods have default implementations in terms of <code>(&lt;&gt;)</code>, and are included in the type class in case some instances can give more efficient implementations than the default. <code>sconcat</code> reduces a nonempty list using <code>(&lt;&gt;)</code>; <code>times1p n</code> is equivalent to (but more efficient than) <code>sconcat . replicate n</code>. See the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/semigroups/latest/doc/html/Data-Semigroup.html">haddock documentation</a> for more information on <code>sconcat</code> and <code>times1p</code>.
</p>
<h2> <span class="mw-headline" id="Laws_4">8.2 Laws</span></h2>
<p>The only law is that <code>(&lt;&gt;)</code> must be associative:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="br0">&#40;</span>x <span class="sy0">&lt;&gt;</span> y<span class="br0">&#41;</span> <span class="sy0">&lt;&gt;</span> z <span class="sy0">=</span> x <span class="sy0">&lt;&gt;</span> <span class="br0">&#40;</span>y <span class="sy0">&lt;&gt;</span> z<span class="br0">&#41;</span></pre></div></div>
<h1> <span class="mw-headline" id="Monoid">9 Monoid</span></h1>
<p>Many semigroups have a special element <span class="texhtml" dir="ltr"><i>e</i></span> for which the binary operation <img class="tex" alt="\oplus" src="/wikiupload/math/b/7/1/b71edd70fcad670e99a9912ba5e55d77.png" /> is the identity, that is, <img class="tex" alt="e \oplus x = x \oplus e = x" src="/wikiupload/math/e/7/6/e7645a24c86dad562419e99ffa653e97.png" /> for every element <span class="texhtml" dir="ltr"><i>x</i></span>.  Such a semigroup-with-identity-element is called a <i>monoid</i>.
</p>
<h2> <span class="mw-headline" id="Definition_5">9.1 Definition</span></h2>
<p>The definition of the <code>Monoid</code> type class (defined in
<code>Data.Monoid</code>; <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html">haddock</a>) is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Monoid a <span class="kw1">where</span>
  mempty  <span class="sy0">::</span> a
  mappend <span class="sy0">::</span> a <span class="sy0">-&gt;</span> a <span class="sy0">-&gt;</span> a
&#160;
  mconcat <span class="sy0">::</span> <span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="sy0">-&gt;</span> a
  mconcat <span class="sy0">=</span> <span class="kw3">foldr</span> mappend mempty</pre></div></div>
<p>The <code>mempty</code> value specifies the identity element of the monoid, and <code>mappend</code>
is the binary operation.  The default definition for <code>mconcat</code>
“reduces” a list of elements by combining them all with <code>mappend</code>,
using a right fold. It is only in the <code>Monoid</code> class so that specific
instances have the option of providing an alternative, more efficient
implementation; usually, you can safely ignore <code>mconcat</code> when creating
a <code>Monoid</code> instance, since its default definition will work just fine.
</p><p>The <code>Monoid</code> methods are rather unfortunately named; they are inspired
by the list instance of <code>Monoid</code>, where indeed <code>mempty = []</code> and <code>mappend = (++)</code>, but this is misleading since many
monoids have little to do with appending (see these <a rel="nofollow" class="external text" href="http://thread.gmane.org/gmane.comp.lang.haskell.cafe/50590">Comments from OCaml Hacker Brian Hurt</a> on the Haskell-cafe mailing list). This was improved in GHC 7.4, where <code>(&lt;&gt;)</code> was added as an alias to <code>mappend</code>.
</p>
<h2> <span class="mw-headline" id="Laws_5">9.2 Laws</span></h2>
<p>Of course, every <code>Monoid</code> instance should actually be a monoid in the
mathematical sense, which implies these laws:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">mempty `mappend` x <span class="sy0">=</span> x
x `mappend` mempty <span class="sy0">=</span> x
<span class="br0">&#40;</span>x `mappend` y<span class="br0">&#41;</span> `mappend` z <span class="sy0">=</span> x `mappend` <span class="br0">&#40;</span>y `mappend` z<span class="br0">&#41;</span></pre></div></div>
<h2> <span class="mw-headline" id="Instances_4">9.3 Instances</span></h2>
<p>There are quite a few interesting <code>Monoid</code> instances defined in <code>Data.Monoid</code>.
</p>
<ul>
<li><code>[a]</code> is a <code>Monoid</code>, with <code>mempty = []</code> and <code>mappend = (++)</code>. It is not hard to check that <code>(x ++ y) ++ z = x ++ (y ++ z)</code> for any lists <code>x</code>, <code>y</code>, and <code>z</code>, and that the empty list is the identity: <code>[] ++ x = x ++ [] = x</code>.</li>
<li>As noted previously, we can make a monoid out of any numeric type under either addition or multiplication.  However, since we can’t have two instances for the same type, <code>Data.Monoid</code> provides two <code>newtype</code> wrappers, <code>Sum</code> and <code>Product</code>, with appropriate <code>Monoid</code> instances.

<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="sy0">&gt;</span> getSum <span class="br0">&#40;</span>mconcat <span class="sy0">.</span> <span class="kw3">map</span> Sum <span class="sy0">$</span> <span class="br0">&#91;</span>1<span class="sy0">..</span>5<span class="br0">&#93;</span><span class="br0">&#41;</span>
15
<span class="sy0">&gt;</span> getProduct <span class="br0">&#40;</span>mconcat <span class="sy0">.</span> <span class="kw3">map</span> Product <span class="sy0">$</span> <span class="br0">&#91;</span>1<span class="sy0">..</span>5<span class="br0">&#93;</span><span class="br0">&#41;</span>
<span class="nu0">120</span></pre></div></div>
<p>This example code is silly, of course; we could just write
</p>
<code>sum [1..5]</code> and <code>product [1..5]</code>.  Nevertheless, these instances are useful in more generalized settings, as we will see in the <a href="/haskellwiki/index.php?title=Foldable&amp;action=edit&amp;redlink=1" class="new" title="Foldable (page does not exist)">section on <code>Foldable</code></a>.</li>
<li><code>Any</code> and <code>All</code> are <code>newtype</code> wrappers providing <code>Monoid</code> instances for <code>Bool</code> (under disjunction and conjunction, respectively).</li>
<li> There are three instances for <code>Maybe</code>: a basic instance which lifts a <code>Monoid</code> instance for <code>a</code> to an instance for <code>Maybe a</code>, and two <code>newtype</code> wrappers <code>First</code> and <code>Last</code> for which <code>mappend</code> selects the first (respectively last) non-<code>Nothing</code> item.</li>
<li><code>Endo a</code> is a newtype wrapper for functions <code>a -&gt; a</code>, which form a monoid under composition.</li>
<li>There are several ways to “lift” <code>Monoid</code> instances to instances with additional structure.  We have already seen that an instance for <code>a</code> can be lifted to an instance for <code>Maybe a</code>.  There are also tuple instances: if <code>a</code> and <code>b</code> are instances of <code>Monoid</code>, then so is <code>(a,b)</code>, using the monoid operations for <code>a</code> and <code>b</code> in the obvious pairwise manner. Finally, if <code>a</code> is a <code>Monoid</code>, then so is the function type <code>e -&gt; a</code> for any <code>e</code>; in particular, <code>g `mappend` h</code> is the function which applies both <code>g</code> and <code>h</code> to its argument and then combines the results using the underlying <code>Monoid</code> instance for <code>a</code>.  This can be quite useful and elegant (see <a rel="nofollow" class="external text" href="http://thread.gmane.org/gmane.comp.lang.haskell.cafe/52416">example</a>).</li>
<li>The type <code>Ordering = LT | EQ | GT</code> is a <code>Monoid</code>, defined in such a way that <code>mconcat (zipWith compare xs ys)</code> computes the lexicographic ordering of <code>xs</code> and <code>ys</code> (if <code>xs</code> and <code>ys</code> have the same length).  In particular, <code>mempty = EQ</code>, and <code>mappend</code> evaluates to its leftmost non-<code>EQ</code> argument (or <code>EQ</code> if both arguments are <code>EQ</code>).  This can be used together with the function instance of <code>Monoid</code> to do some clever things (<a rel="nofollow" class="external text" href="http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx">example</a>).</li>
<li>There are also <code>Monoid</code> instances for several standard data structures in the containers library  (<a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/containers/0.2.0.0/doc/html/index.html">haddock</a>), including <code>Map</code>, <code>Set</code>, and <code>Sequence</code>.</li>
</ul>
<p><code>Monoid</code> is also used to enable several other type class instances.
As noted previously, we can use <code>Monoid</code> to make <code>((,) e)</code> an instance of <code>Applicative</code>:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">instance</span> Monoid e <span class="sy0">=&gt;</span> Applicative <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="sy0">,</span><span class="br0">&#41;</span> e<span class="br0">&#41;</span> <span class="kw1">where</span>
  pure x <span class="sy0">=</span> <span class="br0">&#40;</span>mempty<span class="sy0">,</span> x<span class="br0">&#41;</span>
  <span class="br0">&#40;</span>u<span class="sy0">,</span> f<span class="br0">&#41;</span> <span class="sy0">&lt;*&gt;</span> <span class="br0">&#40;</span>v<span class="sy0">,</span> x<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span>u `mappend` v<span class="sy0">,</span> f x<span class="br0">&#41;</span></pre></div></div>
<p><code>Monoid</code> can be similarly used to make <code>((,) e)</code> an instance of <code>Monad</code> as well; this is known as the <i>writer monad</i>.  As we’ve already seen, <code>Writer</code> and <code>WriterT</code> are a newtype wrapper and transformer for this monad, respectively.
</p><p><code>Monoid</code> also plays a key role in the <code>Foldable</code> type class (see section <a href="#Foldable">Foldable</a>).
</p>
<h2> <span class="mw-headline" id="Other_monoidal_classes:_Alternative.2C_MonadPlus.2C_ArrowPlus">9.4 Other monoidal classes: Alternative, MonadPlus, ArrowPlus</span></h2>
<p>The <code>Alternative</code> type class (<a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#g:2">haddock</a>)
is for <code>Applicative</code> functors which also have
a monoid structure:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Applicative f <span class="sy0">=&gt;</span> Alternative f <span class="kw1">where</span>
  empty <span class="sy0">::</span> f a
  <span class="br0">&#40;</span><span class="sy0">&lt;|&gt;</span><span class="br0">&#41;</span> <span class="sy0">::</span> f a <span class="sy0">-&gt;</span> f a <span class="sy0">-&gt;</span> f a</pre></div></div>
<p>Of course, instances of <code>Alternative</code> should satisfy the monoid laws
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">empty <span class="sy0">&lt;|&gt;</span> x <span class="sy0">=</span> x
x <span class="sy0">&lt;|&gt;</span> empty <span class="sy0">=</span> x
<span class="br0">&#40;</span>x <span class="sy0">&lt;|&gt;</span> y<span class="br0">&#41;</span> <span class="sy0">&lt;|&gt;</span> z <span class="sy0">=</span> x <span class="sy0">&lt;|&gt;</span> <span class="br0">&#40;</span>y <span class="sy0">&lt;|&gt;</span> z<span class="br0">&#41;</span></pre></div></div>
<p>Likewise, <code>MonadPlus</code> (<a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#t:MonadPlus">haddock</a>)
is for <code>Monad</code>s with a monoid structure:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> <span class="kw4">Monad</span> m <span class="sy0">=&gt;</span> MonadPlus m <span class="kw1">where</span>
  mzero <span class="sy0">::</span> m a
  mplus <span class="sy0">::</span> m a <span class="sy0">-&gt;</span> m a <span class="sy0">-&gt;</span> m a</pre></div></div>
<p>The <code>MonadPlus</code> documentation states that it is intended to model
monads which also support “choice and failure”; in addition to the
monoid laws, instances of <code>MonadPlus</code> are expected to satisfy
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">mzero <span class="sy0">&gt;&gt;=</span> f  <span class="sy0">=</span>  mzero
v <span class="sy0">&gt;&gt;</span> mzero   <span class="sy0">=</span>  mzero</pre></div></div>
<p>which explains the sense in which <code>mzero</code> denotes failure. Since
<code>mzero</code> should be the identity for <code>mplus</code>, the computation <code>m1 `mplus` m2</code> succeeds (evaluates to something other than <code>mzero</code>) if
either <code>m1</code> or <code>m2</code> does; so <code>mplus</code> represents choice. The <code>guard</code>
function can also be used with instances of <code>MonadPlus</code>; it requires a
condition to be satisfied and fails (using <code>mzero</code>) if it is not.  A
simple example of a <code>MonadPlus</code> instance is <code>[]</code>, which is exactly the
same as the <code>Monoid</code> instance for <code>[]</code>: the empty list represents
failure, and list concatenation represents choice.  In general,
however, a <code>MonadPlus</code> instance for a type need not be the same as its
<code>Monoid</code> instance; <code>Maybe</code> is an example of such a type.  A great
introduction to the <code>MonadPlus</code> type class, with interesting examples
of its use, is Doug Auclair’s <i>MonadPlus: What a Super Monad!</i> in <a rel="nofollow" class="external text" href="http://www.haskell.org/wikiupload/6/6a/TMR-Issue11.pdf">the Monad.Reader issue 11</a>.
</p><p>There used to be a type class called <code>MonadZero</code> containing only
<code>mzero</code>, representing monads with failure.  The <code>do</code>-notation requires
some notion of failure to deal with failing pattern matches.
Unfortunately, <code>MonadZero</code> was scrapped in favor of adding the <code>fail</code>
method to the <code>Monad</code> class. If we are lucky, someday <code>MonadZero</code> will
be restored, and <code>fail</code> will be banished to the bit bucket where it
belongs (see <a href="/haskellwiki/MonadPlus_reform_proposal" title="MonadPlus reform proposal">MonadPlus reform proposal</a>).  The idea is that any
<code>do</code>-block which uses pattern matching (and hence may fail) would require
a <code>MonadZero</code> constraint; otherwise, only a <code>Monad</code> constraint would be
required.
</p><p>Finally, <code>ArrowZero</code> and <code>ArrowPlus</code> (<a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html#t:ArrowZero">haddock</a>)
represent <code>Arrow</code>s (<a href="#Arrow">see below</a>) with a
monoid structure:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Arrow arr <span class="sy0">=&gt;</span> ArrowZero arr <span class="kw1">where</span>
  zeroArrow <span class="sy0">::</span> b `arr` c
&#160;
<span class="kw1">class</span> ArrowZero arr <span class="sy0">=&gt;</span> ArrowPlus arr <span class="kw1">where</span>
  <span class="br0">&#40;</span><span class="sy0">&lt;+&gt;</span><span class="br0">&#41;</span> <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span></pre></div></div>
<h2> <span class="mw-headline" id="Further_reading_6">9.5 Further reading</span></h2>
<p>Monoids have gotten a fair bit of attention recently, ultimately due
to
<a rel="nofollow" class="external text" href="http://enfranchisedmind.com/blog/posts/random-thoughts-on-haskell/">a blog post by Brian Hurt</a>, in which he
complained about the fact that the names of many Haskell type classes
(<code>Monoid</code> in particular) are taken from abstract mathematics.  This
resulted in <a rel="nofollow" class="external text" href="http://thread.gmane.org/gmane.comp.lang.haskell.cafe/50590">a long Haskell-cafe thread</a>
arguing the point and discussing monoids in general.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ May its name live forever.</span>
</p><p>However, this was quickly followed by several blog posts about
<code>Monoid</code> <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.  First, Dan Piponi
wrote a great introductory post, <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html">Haskell Monoids and their Uses</a>.  This was quickly followed by
Heinrich Apfelmus’s <a rel="nofollow" class="external text" href="http://apfelmus.nfshost.com/monoid-fingertree.html">Monoids and Finger Trees</a>, an accessible exposition of
Hinze and Paterson’s <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/%7Eross/papers/FingerTree.html">classic paper on 2-3 finger trees</a>, which makes very clever
use of <code>Monoid</code> to implement an elegant and generic data structure.
Dan Piponi then wrote two fascinating articles about using <code>Monoids</code>
(and finger trees): <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2009/01/fast-incremental-regular-expression.html">Fast Incremental Regular Expressions</a> and <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2009/01/beyond-regular-expressions-more.html">Beyond Regular Expressions</a>
</p><p>In a similar vein, David Place’s article on improving <code>Data.Map</code> in
order to compute incremental folds (see <a rel="nofollow" class="external text" href="http://www.haskell.org/sitewiki/images/6/6a/TMR-Issue11.pdf">the Monad Reader issue 11</a>)
is also a
good example of using <code>Monoid</code> to generalize a data structure.
</p><p>Some other interesting examples of <code>Monoid</code> use include <a rel="nofollow" class="external text" href="http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx">building elegant list sorting combinators</a>, <a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/2008/04/17/collecting-unstructured-information-with-the-monoid-of-partial-knowledge/">collecting unstructured information</a>, <a rel="nofollow" class="external text" href="http://izbicki.me/blog/gausian-distributions-are-monoids">combining probability distributions</a>, and a brilliant series of posts by Chung-Chieh Shan and Dylan Thurston using <code>Monoid</code>s to <a rel="nofollow" class="external text" href="http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/">elegantly solve a difficult combinatorial puzzle</a> (followed by <a rel="nofollow" class="external text" href="http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers2/">part 2</a>, <a rel="nofollow" class="external text" href="http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers3/">part 3</a>, <a rel="nofollow" class="external text" href="http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers4/">part 4</a>).
</p><p>As unlikely as it sounds, monads can actually be viewed as a sort of
monoid, with <code>join</code> playing the role of the binary operation and
<code>return</code> the role of the identity; see <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html">Dan Piponi’s blog post</a>.
</p>
<h1> <span class="mw-headline" id="Foldable">10 Foldable</span></h1>
<p>The <code>Foldable</code> class, defined in the <code>Data.Foldable</code>
module (<a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html">haddock</a>), abstracts over containers which can be
“folded” into a summary value.  This allows such folding operations
to be written in a container-agnostic way.
</p>
<h2> <span class="mw-headline" id="Definition_6">10.1 Definition</span></h2>
<p>The definition of the <code>Foldable</code> type class is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Foldable t <span class="kw1">where</span>
  fold    <span class="sy0">::</span> Monoid m <span class="sy0">=&gt;</span> t m <span class="sy0">-&gt;</span> m
  foldMap <span class="sy0">::</span> Monoid m <span class="sy0">=&gt;</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> m<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> t a <span class="sy0">-&gt;</span> m
&#160;
  <span class="kw3">foldr</span>   <span class="sy0">::</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> b <span class="sy0">-&gt;</span> b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> b <span class="sy0">-&gt;</span> t a <span class="sy0">-&gt;</span> b
  <span class="kw3">foldl</span>   <span class="sy0">::</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> b <span class="sy0">-&gt;</span> a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> a <span class="sy0">-&gt;</span> t b <span class="sy0">-&gt;</span> a
  <span class="kw3">foldr1</span>  <span class="sy0">::</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> a <span class="sy0">-&gt;</span> a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> t a <span class="sy0">-&gt;</span> a
  <span class="kw3">foldl1</span>  <span class="sy0">::</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> a <span class="sy0">-&gt;</span> a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> t a <span class="sy0">-&gt;</span> a</pre></div></div>
<p>This may look complicated, but in fact, to make a <code>Foldable</code> instance
you only need to implement one method: your choice of <code>foldMap</code> or
<code>foldr</code>.  All the other methods have default implementations in terms
of these, and are presumably included in the class in case more
efficient implementations can be provided.
</p>
<h2> <span class="mw-headline" id="Instances_and_examples">10.2 Instances and examples</span></h2>
<p>The type of <code>foldMap</code> should make it clear what it is supposed to do:
given a way to convert the data in a container into a <code>Monoid</code> (a
function <code>a -&gt; m</code>) and a container of <code>a</code>’s (<code>t a</code>), <code>foldMap</code>
provides a way to iterate over the entire contents of the container,
converting all the <code>a</code>’s to <code>m</code>’s and combining all the <code>m</code>’s with
<code>mappend</code>. The following code shows two examples: a simple
implementation of <code>foldMap</code> for lists, and a binary tree example
provided by the <code>Foldable</code> documentation.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">instance</span> Foldable <span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="kw1">where</span>
  foldMap g <span class="sy0">=</span> mconcat <span class="sy0">.</span> <span class="kw3">map</span> g
&#160;
<span class="kw1">data</span> Tree a <span class="sy0">=</span> Empty <span class="sy0">|</span> Leaf a <span class="sy0">|</span> Node <span class="br0">&#40;</span>Tree a<span class="br0">&#41;</span> a <span class="br0">&#40;</span>Tree a<span class="br0">&#41;</span>
&#160;
<span class="kw1">instance</span> Foldable Tree <span class="kw1">where</span>
  foldMap f Empty        <span class="sy0">=</span> mempty
  foldMap f <span class="br0">&#40;</span>Leaf x<span class="br0">&#41;</span>     <span class="sy0">=</span> f x
  foldMap f <span class="br0">&#40;</span>Node l k r<span class="br0">&#41;</span> <span class="sy0">=</span> foldMap f l `mappend` f k `mappend` foldMap f r</pre></div></div>
<p>The <code>foldr</code> function has a type similar to the <code>foldr</code> found in the <code>Prelude</code>, but
more general, since the <code>foldr</code> in the <code>Prelude</code> works only on lists.
</p><p>The <code>Foldable</code> module also provides instances for <code>Maybe</code> and <code>Array</code>;
additionally, many of the data structures found in the standard <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/containers">containers library</a> (for example, <code>Map</code>, <code>Set</code>, <code>Tree</code>,
and <code>Sequence</code>) provide their own <code>Foldable</code> instances.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> What is the type of <code>foldMap . foldMap</code>?  Or <code>foldMap . foldMap . foldMap</code>, etc.?  What do they do?
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Derived_folds">10.3 Derived folds</span></h2>
<p>Given an instance of <code>Foldable</code>, we can write generic,
container-agnostic functions such as:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="co1">-- Compute the size of any container.</span>
containerSize <span class="sy0">::</span> Foldable f <span class="sy0">=&gt;</span> f a <span class="sy0">-&gt;</span> <span class="kw4">Int</span>
containerSize <span class="sy0">=</span> getSum <span class="sy0">.</span> foldMap <span class="br0">&#40;</span><span class="kw3">const</span> <span class="br0">&#40;</span>Sum <span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
&#160;
<span class="co1">-- Compute a list of elements of a container satisfying a predicate.</span>
filterF <span class="sy0">::</span> Foldable f <span class="sy0">=&gt;</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> <span class="kw4">Bool</span><span class="br0">&#41;</span> <span class="sy0">-&gt;</span> f a <span class="sy0">-&gt;</span> <span class="br0">&#91;</span>a<span class="br0">&#93;</span>
filterF p <span class="sy0">=</span> foldMap <span class="br0">&#40;</span>\a <span class="sy0">-&gt;</span> <span class="kw1">if</span> p a <span class="kw1">then</span> <span class="br0">&#91;</span>a<span class="br0">&#93;</span> <span class="kw1">else</span> <span class="br0">&#91;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>
&#160;
<span class="co1">-- Get a list of all the Strings in a container which include the</span>
<span class="co1">-- letter a.</span>
aStrings <span class="sy0">::</span> Foldable f <span class="sy0">=&gt;</span> f <span class="kw4">String</span> <span class="sy0">-&gt;</span> <span class="br0">&#91;</span><span class="kw4">String</span><span class="br0">&#93;</span>
aStrings <span class="sy0">=</span> filterF <span class="br0">&#40;</span><span class="kw3">elem</span> 'a'<span class="br0">&#41;</span></pre></div></div>
<p>The <code>Foldable</code> module also provides a large number of predefined
folds, many of which are generalized versions of <code>Prelude</code> functions of the
same name that only work on lists: <code>concat</code>, <code>concatMap</code>, <code>and</code>,
<code>or</code>, <code>any</code>, <code>all</code>, <code>sum</code>, <code>product</code>, <code>maximum</code>(<code>By</code>),
<code>minimum</code>(<code>By</code>), <code>elem</code>, <code>notElem</code>, and <code>find</code>.
</p><p>The important function <code>toList</code> is also provided, which turns any <code>Foldable</code> structure into a list of its elements in left-right order; it works by folding with the list monoid.
</p><p>There are also generic functions that work with <code>Applicative</code> or
<code>Monad</code> instances to generate some sort of computation from each
element in a container, and then perform all the side effects from
those computations, discarding the results: <code>traverse_</code>, <code>sequenceA_</code>,
and others.  The results must be discarded because the <code>Foldable</code>
class is too weak to specify what to do with them: we cannot, in
general, make an arbitrary <code>Applicative</code> or <code>Monad</code> instance into a <code>Monoid</code>, but we can make <code>m ()</code> into a <code>Monoid</code> for any such <code>m</code>.  If we do have an <code>Applicative</code> or <code>Monad</code> with a monoid
structure—that is, an <code>Alternative</code> or a <code>MonadPlus</code>—then we can
use the <code>asum</code> or <code>msum</code> functions, which can combine the results as
well.  Consult the <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html"><code>Foldable</code> documentation</a> for
more details on any of these functions.
</p><p>Note that the <code>Foldable</code> operations always forget the structure of
the container being folded.  If we start with a container of type <code>t a</code> for some <code>Foldable t</code>, then <code>t</code> will never appear in the output
type of any operations defined in the <code>Foldable</code> module.  Many times
this is exactly what we want, but sometimes we would like to be able
to generically traverse a container while preserving its
structure—and this is exactly what the <code>Traversable</code> class provides,
which will be discussed in the next section.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> Implement <code>toList&#160;:: Foldable f =&gt; f a -&gt; [a]</code>.
</li><li> Pick some of the following functions to implement: <code>concat</code>, <code>concatMap</code>, <code>and</code>, <code>or</code>, <code>any</code>, <code>all</code>, <code>sum</code>, <code>product</code>, <code>maximum</code>(<code>By</code>), <code>minimum</code>(<code>By</code>), <code>elem</code>, <code>notElem</code>, and <code>find</code>.  Figure out how they generalize to <code>Foldable</code> and come up with elegant implementations using <code>fold</code> or <code>foldMap</code> along with appropriate <code>Monoid</code> instances.
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Foldable_actually_isn.27t">10.4 Foldable actually isn't</span></h2>
<p>The generic term "fold" is often used to refer to the more technical concept of <a href="/haskellwiki/Catamorphisms" title="Catamorphisms">catamorphism</a>. Intuitively, given a way to summarize "one level of structure" (where recursive subterms have already been replaced with their summaries), a catamorphism can summarize an entire recursive structure.  It is important to realize that <code>Foldable</code> does <i>not</i> correspond to catamorphisms, but to something weaker.  In particular, <code>Foldable</code> allows observing only the left-right order of elements within a structure, not the actual structure itself.  Put another way, every use of <code>Foldable</code> can be expressed in terms of <code>toList</code>.  For example, <code>fold</code> itself is equivalent to <code>mconcat . toList</code>.
</p><p>This is sufficient for many tasks, but not all.  For example, consider trying to compute the depth of a <code>Tree</code>: try as we might, there is no way to implement it using <code>Foldable</code>.  However, it <i>can</i> be implemented as a catamorphism.
</p>
<h2> <span class="mw-headline" id="Further_reading_7">10.5 Further reading</span></h2>
<p>The <code>Foldable</code> class had its genesis in <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html">McBride and Paterson’s paper</a>
introducing <code>Applicative</code>, although it has
been fleshed out quite a bit from the form in the paper.
</p><p>An interesting use of <code>Foldable</code> (as well as <code>Traversable</code>) can be
found in Janis Voigtländer’s paper <a rel="nofollow" class="external text" href="http://doi.acm.org/10.1145/1480881.1480904">Bidirectionalization for free!</a>.
</p>
<h1> <span class="mw-headline" id="Traversable">11 Traversable</span></h1>
<h2> <span class="mw-headline" id="Definition_7">11.1 Definition</span></h2>
<p>The <code>Traversable</code> type class, defined in the <code>Data.Traversable</code>
module (<a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Traversable.html">haddock</a>), is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> <span class="br0">&#40;</span><span class="kw4">Functor</span> t<span class="sy0">,</span> Foldable t<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> Traversable t <span class="kw1">where</span>
  traverse  <span class="sy0">::</span> Applicative f <span class="sy0">=&gt;</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> f b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> t a <span class="sy0">-&gt;</span> f <span class="br0">&#40;</span>t b<span class="br0">&#41;</span>
  sequenceA <span class="sy0">::</span> Applicative f <span class="sy0">=&gt;</span> t <span class="br0">&#40;</span>f a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> f <span class="br0">&#40;</span>t a<span class="br0">&#41;</span>
  <span class="kw3">mapM</span>      <span class="sy0">::</span>       <span class="kw4">Monad</span> m <span class="sy0">=&gt;</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> m b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> t a <span class="sy0">-&gt;</span> m <span class="br0">&#40;</span>t b<span class="br0">&#41;</span>
  <span class="kw3">sequence</span>  <span class="sy0">::</span>       <span class="kw4">Monad</span> m <span class="sy0">=&gt;</span> t <span class="br0">&#40;</span>m a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> m <span class="br0">&#40;</span>t a<span class="br0">&#41;</span></pre></div></div>
<p>As you can see, every <code>Traversable</code> is also a foldable functor.  Like
<code>Foldable</code>, there is a lot in this type class, but making instances is
actually rather easy: one need only implement <code>traverse</code> or
<code>sequenceA</code>; the other methods all have default implementations in
terms of these functions.  A good exercise is to figure out what the default
implementations should be: given either <code>traverse</code> or <code>sequenceA</code>, how
would you define the other three methods?  (Hint for <code>mapM</code>:
<code>Control.Applicative</code> exports the <code>WrapMonad</code> newtype, which makes any
<code>Monad</code> into an <code>Applicative</code>. The <code>sequence</code> function can be implemented in terms
of <code>mapM</code>.)
</p>
<h2> <span class="mw-headline" id="Intuition_4">11.2 Intuition</span></h2>
<p>The key method of the <code>Traversable</code> class, and the source of its
unique power, is <code>sequenceA</code>.  Consider its type:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  sequenceA <span class="sy0">::</span> Applicative f <span class="sy0">=&gt;</span> t <span class="br0">&#40;</span>f a<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> f <span class="br0">&#40;</span>t a<span class="br0">&#41;</span></pre></div></div>
<p>This answers the fundamental question: when can we commute two
functors?  For example, can we turn a tree of lists into a list of
trees?
</p><p>The ability to compose two monads depends crucially on this ability to
commute functors. Intuitively, if we want to build a composed monad
<code>M a = m (n a)</code> out of monads <code>m</code> and <code>n</code>, then to be able to
implement <code>join&#160;:: M (M a) -&gt; M a</code>, that is,
<code>join&#160;:: m (n (m (n a))) -&gt; m (n a)</code>, we have to be able to commute
the <code>n</code> past the <code>m</code> to get <code>m (m (n (n a)))</code>, and then we can use the
<code>join</code>s for <code>m</code> and <code>n</code> to produce something of type <code>m (n a)</code>.  See
<a rel="nofollow" class="external text" href="http://web.cecs.pdx.edu/~mpj/pubs/springschool.html">Mark Jones’s paper</a> for more details.
</p><p>Alternatively, looking at the type of <code>traverse</code>,
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  traverse <span class="sy0">::</span> Applicative f <span class="sy0">=&gt;</span> <span class="br0">&#40;</span>a <span class="sy0">-&gt;</span> f b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> t a <span class="sy0">-&gt;</span> f <span class="br0">&#40;</span>t b<span class="br0">&#41;</span></pre></div></div>
<p>leads us to view <code>Traversable</code> as a generalization of <code>Functor</code>.  <code>traverse</code> is an "effectful <code>fmap</code>": it allows us to map over a structure of type <code>t a</code>, applying a function to every element of type <code>a</code> and in order to produce a new structure of type <code>t b</code>; but along the way the function may have some effects (captured by the applicative functor <code>f</code>).
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> There are at least two natural ways to turn a tree of lists into a list of trees.  What are they, and why?
</li><li> Give a natural way to turn a list of trees into a tree of lists.
</li><li> What is the type of <code>traverse . traverse</code>? What does it do?
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Instances_and_examples_2">11.3 Instances and examples</span></h2>
<p>What’s an example of a <code>Traversable</code> instance?
The following code shows an example instance for the same
<code>Tree</code> type used as an example in the previous <code>Foldable</code> section.  It
is instructive to compare this instance with a <code>Functor</code> instance for
<code>Tree</code>, which is also shown.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">data</span> Tree a <span class="sy0">=</span> Empty <span class="sy0">|</span> Leaf a <span class="sy0">|</span> Node <span class="br0">&#40;</span>Tree a<span class="br0">&#41;</span> a <span class="br0">&#40;</span>Tree a<span class="br0">&#41;</span>
&#160;
<span class="kw1">instance</span> Traversable Tree <span class="kw1">where</span>
  traverse g Empty        <span class="sy0">=</span> pure Empty
  traverse g <span class="br0">&#40;</span>Leaf x<span class="br0">&#41;</span>     <span class="sy0">=</span> Leaf <span class="sy0">&lt;$&gt;</span> g x
  traverse g <span class="br0">&#40;</span>Node l x r<span class="br0">&#41;</span> <span class="sy0">=</span> Node <span class="sy0">&lt;$&gt;</span> traverse g l
                                 <span class="sy0">&lt;*&gt;</span> g x
                                 <span class="sy0">&lt;*&gt;</span> traverse g r
&#160;
<span class="kw1">instance</span> <span class="kw4">Functor</span> Tree <span class="kw1">where</span>
  <span class="kw3">fmap</span>     g Empty        <span class="sy0">=</span> Empty
  <span class="kw3">fmap</span>     g <span class="br0">&#40;</span>Leaf x<span class="br0">&#41;</span>     <span class="sy0">=</span> Leaf <span class="sy0">$</span> g x
  <span class="kw3">fmap</span>     g <span class="br0">&#40;</span>Node l x r<span class="br0">&#41;</span> <span class="sy0">=</span> Node <span class="br0">&#40;</span><span class="kw3">fmap</span> g l<span class="br0">&#41;</span>
                                 <span class="br0">&#40;</span>g x<span class="br0">&#41;</span>
                                 <span class="br0">&#40;</span><span class="kw3">fmap</span> g r<span class="br0">&#41;</span></pre></div></div>
<p>It should be clear that the <code>Traversable</code> and <code>Functor</code> instances for
<code>Tree</code> are almost identical; the only difference is that the <code>Functor</code>
instance involves normal function application, whereas the
applications in the <code>Traversable</code> instance take place within an
<code>Applicative</code> context, using <code>(&lt;$&gt;)</code> and <code>(&lt;*&gt;)</code>.  In fact, this will
be
true for any type.
</p><p>Any <code>Traversable</code> functor is also <code>Foldable</code>, and a <code>Functor</code>.  We can see
this not only from the class declaration, but by the fact that we can
implement the methods of both classes given only the <code>Traversable</code>
methods.
</p><p>The standard libraries provide a number of <code>Traversable</code> instances,
including instances for <code>[]</code>, <code>Maybe</code>, <code>Map</code>, <code>Tree</code>, and <code>Sequence</code>.
Notably, <code>Set</code> is not <code>Traversable</code>, although it is <code>Foldable</code>.
</p>
<table style="margin-left: auto; margin-right: auto; width: 70ex; background: transparent; border: 1px solid #aaa; padding: 0.5em;"><tr>
<th>Exercises</th></tr>
<tr><td>
<ol><li> Implement <code>fmap</code> and <code>foldMap</code> using only the <code>Traversable</code> methods.  (Note that the <code>Traversable</code> module provides these implementations as <code>fmapDefault</code> and <code>foldMapDefault</code>.)
</li></ol>
</td>
</tr></table>
<h2> <span class="mw-headline" id="Laws_6">11.4 Laws</span></h2>
<p>Any instance of <code>Traversable</code> must satisfy the following two laws, where <code>Identity</code> is the identity functor (as defined in the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Data-Functor-Identity.html"><code>Data.Functor.Identity</code> module</a> from the <code>transformers</code> package), and <code>Compose</code> wraps the composition of two functors (as defined in <a rel="nofollow" class="external text" href="http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Compose.html"><code>Data.Functor.Compose</code></a>):
</p>
<ol><li> <code>traverse Identity = Identity</code>
</li><li> <code>traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f</code>
</li></ol>
<p>The first law essentially says that traversals cannot make up arbitrary effects.  The second law explains how doing two traversals in sequence can be collapsed to a single traversal.
</p><p>Additionally, suppose <code>eta</code> is an "<code>Applicative</code> morphism", that is,
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">  eta <span class="sy0">::</span> <span class="kw1">forall</span> a f g<span class="sy0">.</span> <span class="br0">&#40;</span>Applicative f<span class="sy0">,</span> Applicative g<span class="br0">&#41;</span> <span class="sy0">=&gt;</span> f a <span class="sy0">-&gt;</span> g a</pre></div></div>
<p>and <code>eta</code> preserves the <code>Applicative</code> operations: <code>eta (pure x) = pure x</code> and <code>eta (x &lt;*&gt; y) = eta x &lt;*&gt; eta y</code>.  Then, by parametricity, any instance of <code>Traversable</code> satisfying the above two laws will also satisfy <code>eta . traverse f = traverse (eta . f)</code>.
</p>
<h2> <span class="mw-headline" id="Further_reading_8">11.5 Further reading</span></h2>
<p>The <code>Traversable</code> class also had its genesis in <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/Applicative.html">McBride and Paterson’s <code>Applicative</code> paper</a>,
and is described in more detail in Gibbons and Oliveira, <a rel="nofollow" class="external text" href="http://www.comlab.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf">The Essence of the Iterator Pattern</a>,
which also contains a wealth of references to related work.
</p><p><code>Traversable</code> forms a core component of Edward Kmett's <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/lens">lens library</a>.  Watching <a rel="nofollow" class="external text" href="https://vimeo.com/56063074">Edward's talk on the subject</a> is a highly recommended way to gain better insight into <code>Traversable</code>, <code>Foldable</code>, <code>Applicative</code>, and many other things besides.
</p><p>For references on the <code>Traversable</code> laws, see Russell O'Connor's <a rel="nofollow" class="external text" href="http://article.gmane.org/gmane.comp.lang.haskell.libraries/17778">mailing list post</a> (and subsequent thread).
</p>
<h1> <span class="mw-headline" id="Category">12 Category</span></h1>
<p><code>Category</code> is a relatively recent addition to the Haskell standard libraries.  It generalizes the notion of function composition to general “morphisms”.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ GHC 7.6.1 changed its rules regarding types and type variables.  Now, any operator at the type level is treated as a type <i>constructor</i> rather than a type <i>variable</i>; prior to GHC 7.6.1 it was possible to use <code>(~&gt;)</code> instead of <code>`arr`</code>.  For more information, see <a rel="nofollow" class="external text" href="http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/21350">the discussion on the GHC-users mailing list</a>.  For a new approach to nice arrow notation that works with GHC 7.6.1, see <a rel="nofollow" class="external text" href="http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22615">this message</a> and also <a rel="nofollow" class="external text" href="http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22616">this message</a> from Edward Kmett, though for simplicity I haven't adopted it here.</span>
The definition of the <code>Category</code> type class (from
<code>Control.Category</code>; <a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Category.html">haddock</a>) is shown below.  For ease of reading, note that I have used an infix type variable <code>`arr`</code>, in parallel with the infix function type constructor <code>(-&gt;)</code>.  <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span> This syntax is not part of Haskell 2010. The second definition shown is the one used in the standard libraries. For the remainder of this document, I will use the infix type constructor <code>`arr`</code> for <code>Category</code> as well as <code>Arrow</code>.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Category arr <span class="kw1">where</span>
  <span class="kw3">id</span>  <span class="sy0">::</span> a `arr` a
  <span class="br0">&#40;</span><span class="sy0">.</span><span class="br0">&#41;</span> <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>a `arr` b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>a `arr` c<span class="br0">&#41;</span>
&#160;
<span class="co1">-- The same thing, with a normal (prefix) type constructor</span>
<span class="kw1">class</span> Category cat <span class="kw1">where</span>
  <span class="kw3">id</span>  <span class="sy0">::</span> cat a a
  <span class="br0">&#40;</span><span class="sy0">.</span><span class="br0">&#41;</span> <span class="sy0">::</span> cat b c <span class="sy0">-&gt;</span> cat a b <span class="sy0">-&gt;</span> cat a c</pre></div></div>
<p>Note that an instance of <code>Category</code> should be a type constructor which takes two type arguments, that is, something of kind <code>* -&gt; * -&gt; *</code>. It is instructive to imagine the type constructor variable <code>cat</code> replaced by the function constructor <code>(-&gt;)</code>: indeed, in this case we recover precisely the familiar identity function <code>id</code> and function composition operator <code>(.)</code> defined in the standard <code>Prelude</code>.
</p><p>Of course, the <code>Category</code> module provides exactly such an instance of
<code>Category</code> for <code>(-&gt;)</code>.  But it also provides one other instance, shown below, which should be familiar from the previous discussion of the <code>Monad</code> laws.  <code>Kleisli m a b</code>, as defined in the <code>Control.Arrow</code> module, is just a <code>newtype</code> wrapper  around <code>a -&gt; m b</code>.
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">newtype</span> Kleisli m a b <span class="sy0">=</span> Kleisli <span class="br0">&#123;</span> runKleisli <span class="sy0">::</span> a <span class="sy0">-&gt;</span> m b <span class="br0">&#125;</span>
&#160;
<span class="kw1">instance</span> <span class="kw4">Monad</span> m <span class="sy0">=&gt;</span> Category <span class="br0">&#40;</span>Kleisli m<span class="br0">&#41;</span> <span class="kw1">where</span>
  <span class="kw3">id</span> <span class="sy0">=</span> Kleisli <span class="kw3">return</span>
  Kleisli g <span class="sy0">.</span> Kleisli h <span class="sy0">=</span> Kleisli <span class="br0">&#40;</span>h <span class="sy0">&gt;=&gt;</span> g<span class="br0">&#41;</span></pre></div></div>
<p>The only law that <code>Category</code> instances should satisfy is that <code>id</code> and <code>(.)</code> should form a monoid—that is, <code>id</code> should be the identity of <code>(.)</code>, and <code>(.)</code> should be associative.
</p><p>Finally, the <code>Category</code> module exports two additional operators:
<code>(&lt;&lt;&lt;)</code>, which is just a synonym for <code>(.)</code>, and <code>(&gt;&gt;&gt;)</code>, which is <code>(.)</code> with its arguments reversed.  (In previous versions of the libraries, these operators were defined as part of the <code>Arrow</code> class.)
</p>
<h2> <span class="mw-headline" id="Further_reading_9">12.1 Further reading</span></h2>
<p>The name <code>Category</code> is a bit misleading, since the <code>Category</code> class cannot represent arbitrary categories, but only categories whose objects are objects of <code>Hask</code>, the category of Haskell types.  For a more general treatment of categories within Haskell, see the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/category-extras">category-extras package</a>.  For more about category theory in general, see the excellent <a rel="nofollow" class="external text" href="http://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell wikibook page</a>,
<a rel="nofollow" class="external text" href="http://books.google.com/books/about/Category_theory.html?id=-MCJ6x2lC7oC">Steve Awodey’s new book</a>, Benjamin Pierce’s <a rel="nofollow" class="external text" href="http://books.google.com/books/about/Basic_category_theory_for_computer_scien.html?id=ezdeaHfpYPwC">Basic category theory for computer scientists</a>, or <a rel="nofollow" class="external text" href="http://folli.loria.fr/cds/1999/esslli99/courses/barr-wells.html">Barr and Wells’s category theory lecture notes</a>. <a rel="nofollow" class="external text" href="http://dekudekuplex.wordpress.com/2009/01/19/motivating-learning-category-theory-for-non-mathematicians/">Benjamin Russell’s blog post</a>
is another good source of motivation and category theory links.  You certainly don’t need to know any category theory to be a successful and productive Haskell programmer, but it does lend itself to much deeper appreciation of Haskell’s underlying theory.
</p>
<h1> <span class="mw-headline" id="Arrow">13 Arrow</span></h1>
<p>The <code>Arrow</code> class represents another abstraction of computation, in a
similar vein to <code>Monad</code> and <code>Applicative</code>.  However, unlike <code>Monad</code>
and <code>Applicative</code>, whose types only reflect their output, the type of
an <code>Arrow</code> computation reflects both its input and output.  Arrows
generalize functions: if <code>arr</code> is an instance of <code>Arrow</code>, a value of
type <code>b `arr` c</code> can be thought of as a computation which takes values of
type <code>b</code> as input, and produces values of type <code>c</code> as output.  In the
<code>(-&gt;)</code> instance of <code>Arrow</code> this is just a pure function; in general, however,
an arrow may represent some sort of “effectful” computation.
</p>
<h2> <span class="mw-headline" id="Definition_8">13.1 Definition</span></h2>
<p>The definition of the <code>Arrow</code> type class, from
<code>Control.Arrow</code> (<a rel="nofollow" class="external text" href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html">haddock</a>), is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Category arr <span class="sy0">=&gt;</span> Arrow arr <span class="kw1">where</span>
  arr <span class="sy0">::</span> <span class="br0">&#40;</span>b <span class="sy0">-&gt;</span> c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span>
  first <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>b<span class="sy0">,</span> d<span class="br0">&#41;</span> `arr` <span class="br0">&#40;</span>c<span class="sy0">,</span> d<span class="br0">&#41;</span><span class="br0">&#41;</span>
  second <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>d<span class="sy0">,</span> b<span class="br0">&#41;</span> `arr` <span class="br0">&#40;</span>d<span class="sy0">,</span> c<span class="br0">&#41;</span><span class="br0">&#41;</span>
  <span class="br0">&#40;</span><span class="sy0">***</span><span class="br0">&#41;</span> <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>b' `arr` c'<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>b<span class="sy0">,</span> b'<span class="br0">&#41;</span> `arr` <span class="br0">&#40;</span>c<span class="sy0">,</span> c'<span class="br0">&#41;</span><span class="br0">&#41;</span>
  <span class="br0">&#40;</span><span class="sy0">&amp;&amp;</span>&amp;<span class="br0">&#41;</span> <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>b `arr` c'<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>b `arr` <span class="br0">&#40;</span>c<span class="sy0">,</span> c'<span class="br0">&#41;</span><span class="br0">&#41;</span></pre></div></div>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ In versions of the <code>base</code>
package prior to version 4, there is no <code>Category</code> class, and the
<code>Arrow</code> class includes the arrow composition operator <code>(&gt;&gt;&gt;)</code>. It
also includes <code>pure</code> as a synonym for <code>arr</code>, but this was removed
since it conflicts with the <code>pure</code> from <code>Applicative</code>.</span>
</p><p>The first thing to note is the <code>Category</code> class constraint, which
means that we get identity arrows and arrow composition for free:
given two arrows <code>g&#160;:: b `arr` c</code> and <code>h&#160;:: c `arr` d</code>, we can form their
composition <code>g &gt;&gt;&gt; h&#160;:: b `arr` d</code> <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>.
</p><p>As should be a familiar pattern by now, the only methods which must be
defined when writing a new instance of <code>Arrow</code> are <code>arr</code> and <code>first</code>;
the other methods have default definitions in terms of these, but are
included in the <code>Arrow</code> class so that they can be overridden with more
efficient implementations if desired.
</p>
<h2> <span class="mw-headline" id="Intuition_5">13.2 Intuition</span></h2>
<p>Let’s look at each of the arrow methods in turn.  <a rel="nofollow" class="external text" href="http://www.haskell.org/arrows/">Ross Paterson’s web page on arrows</a> has nice diagrams which can help
build intuition.
</p>
<ul><li> The <code>arr</code> function takes any function <code>b -&gt; c</code> and turns it into a generalized arrow <code>b `arr` c</code>.  The <code>arr</code> method justifies the claim that arrows generalize functions, since it says that we can treat any function as an arrow.  It is intended that the arrow <code>arr g</code> is “pure” in the sense that it only computes <code>g</code> and has no “effects” (whatever that might mean for any particular arrow type).
</li></ul>
<ul><li> The <code>first</code> method turns any arrow from <code>b</code> to   <code>c</code> into an arrow from <code>(b,d)</code> to <code>(c,d)</code>.  The idea is that <code>first g</code> uses <code>g</code> to process the first element of a tuple, and lets the second element pass through unchanged.  For the function instance of <code>Arrow</code>, of course, <code>first g (x,y) = (g x, y)</code>.
</li></ul>
<ul><li> The <code>second</code> function is similar to <code>first</code>, but with the elements of the tuples swapped.  Indeed, it can be defined in terms of <code>first</code> using an auxiliary function <code>swap</code>, defined by <code>swap (x,y) = (y,x)</code>.
</li></ul>
<ul><li> The <code>(***)</code> operator is “parallel composition” of arrows: it takes two arrows and makes them into one arrow on tuples, which has the behavior of the first arrow on the first element of a tuple, and the behavior of the second arrow on the second element.  The mnemonic is that <code>g *** h</code> is the <i>product</i> (hence <code>*</code>) of <code>g</code> and <code>h</code>. For the function instance of <code>Arrow</code>, we define <code>(g *** h) (x,y) = (g x, h y)</code>.  The default implementation of <code>(***)</code> is in terms of <code>first</code>, <code>second</code>, and sequential arrow composition <code>(&gt;&gt;&gt;)</code>.  The reader may also wish to think about how to implement <code>first</code> and <code>second</code> in terms of <code>(***)</code>.
</li></ul>
<ul><li> The <code>(&amp;&amp;&amp;)</code> operator is “fanout composition” of arrows: it takes two arrows <code>g</code> and <code>h</code> and makes them into a new arrow <code>g &amp;&amp;&amp; h</code> which supplies its input as the input to both <code>g</code> and <code>h</code>, returning their results as a tuple.  The mnemonic is that <code>g &amp;&amp;&amp; h</code> performs both <code>g</code> <i>and</i> <code>h</code> (hence <code>&amp;</code>) on its input.  For functions, we define <code>(g &amp;&amp;&amp; h) x = (g x, h x)</code>.
</li></ul>
<h2> <span class="mw-headline" id="Instances_5">13.3 Instances</span></h2>
<p>The <code>Arrow</code> library itself only provides two <code>Arrow</code> instances, both
of which we have already seen: <code>(-&gt;)</code>, the normal function
constructor, and <code>Kleisli m</code>, which makes functions of
type <code>a -&gt; m b</code> into <code>Arrow</code>s for any <code>Monad m</code>. These instances are:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">instance</span> Arrow <span class="br0">&#40;</span><span class="sy0">-&gt;</span><span class="br0">&#41;</span> <span class="kw1">where</span>
  arr g <span class="sy0">=</span> g
  first g <span class="br0">&#40;</span>x<span class="sy0">,</span>y<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span>g x<span class="sy0">,</span> y<span class="br0">&#41;</span>
&#160;
<span class="kw1">newtype</span> Kleisli m a b <span class="sy0">=</span> Kleisli <span class="br0">&#123;</span> runKleisli <span class="sy0">::</span> a <span class="sy0">-&gt;</span> m b <span class="br0">&#125;</span>
&#160;
<span class="kw1">instance</span> <span class="kw4">Monad</span> m <span class="sy0">=&gt;</span> Arrow <span class="br0">&#40;</span>Kleisli m<span class="br0">&#41;</span> <span class="kw1">where</span>
  arr f <span class="sy0">=</span> Kleisli <span class="br0">&#40;</span><span class="kw3">return</span> <span class="sy0">.</span> f<span class="br0">&#41;</span>
  first <span class="br0">&#40;</span>Kleisli f<span class="br0">&#41;</span> <span class="sy0">=</span> Kleisli <span class="br0">&#40;</span>\ <span class="sy0">~</span><span class="br0">&#40;</span>b<span class="sy0">,</span>d<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="kw1">do</span> c <span class="sy0">&lt;-</span> f b
                                              <span class="kw3">return</span> <span class="br0">&#40;</span>c<span class="sy0">,</span>d<span class="br0">&#41;</span> <span class="br0">&#41;</span></pre></div></div>
<h2> <span class="mw-headline" id="Laws_7">13.4 Laws</span></h2>
<p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ See <a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016/S0167-6423(99)00023-4">John Hughes: Generalising monads to arrows</a>; <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf">Sam Lindley, Philip Wadler, Jeremy Yallop: The arrow calculus</a>; <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/fop.html">Ross Paterson: Programming with Arrows</a>.</span>
</p><p>There are quite a few laws that instances of <code>Arrow</code> should
satisfy <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1">                       arr <span class="kw3">id</span>  <span class="sy0">=</span>  <span class="kw3">id</span>
                  arr <span class="br0">&#40;</span>h <span class="sy0">.</span> g<span class="br0">&#41;</span>  <span class="sy0">=</span>  arr g <span class="sy0">&gt;&gt;&gt;</span> arr h
                first <span class="br0">&#40;</span>arr g<span class="br0">&#41;</span>  <span class="sy0">=</span>  arr <span class="br0">&#40;</span>g <span class="sy0">***</span> <span class="kw3">id</span><span class="br0">&#41;</span>
              first <span class="br0">&#40;</span>g <span class="sy0">&gt;&gt;&gt;</span> h<span class="br0">&#41;</span>  <span class="sy0">=</span>  first g <span class="sy0">&gt;&gt;&gt;</span> first h
   first g <span class="sy0">&gt;&gt;&gt;</span> arr <span class="br0">&#40;</span><span class="kw3">id</span> <span class="sy0">***</span> h<span class="br0">&#41;</span>  <span class="sy0">=</span>  arr <span class="br0">&#40;</span><span class="kw3">id</span> <span class="sy0">***</span> h<span class="br0">&#41;</span> <span class="sy0">&gt;&gt;&gt;</span> first g
          first g <span class="sy0">&gt;&gt;&gt;</span> arr <span class="kw3">fst</span>  <span class="sy0">=</span>  arr <span class="kw3">fst</span> <span class="sy0">&gt;&gt;&gt;</span> g
first <span class="br0">&#40;</span>first g<span class="br0">&#41;</span> <span class="sy0">&gt;&gt;&gt;</span> arr assoc  <span class="sy0">=</span>  arr assoc <span class="sy0">&gt;&gt;&gt;</span> first g
&#160;
assoc <span class="br0">&#40;</span><span class="br0">&#40;</span>x<span class="sy0">,</span>y<span class="br0">&#41;</span><span class="sy0">,</span>z<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span>x<span class="sy0">,</span><span class="br0">&#40;</span>y<span class="sy0">,</span>z<span class="br0">&#41;</span><span class="br0">&#41;</span></pre></div></div>
<p>Note that this version of the laws is slightly different than the laws given in the
first two above references, since several of the laws have now been
subsumed by the <code>Category</code> laws (in particular, the requirements that
<code>id</code> is the identity arrow and that <code>(&gt;&gt;&gt;)</code> is associative).  The laws
shown here follow those in Paterson’s Programming with Arrows, which uses the
<code>Category</code> class.
</p><p><span style="float: right; clear: right; width: 12em; padding: 0.5em; margin: 0 0.3em 1em 0.6em; border: 1px solid #ddd; background: #ffd;">∗ Unless category-theory-induced insomnolence is your cup of tea.</span>
</p><p>The reader is advised not to lose too much sleep over the <code>Arrow</code>
laws <span style="border: 1px solid #ddd; background: #ffa; padding: 0 0.15em">∗</span>, since it is not essential to understand them in order to
program with arrows. There are also laws that <code>ArrowChoice</code>,
<code>ArrowApply</code>, and <code>ArrowLoop</code> instances should satisfy; the interested
reader should consult <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/fop.html">Paterson: Programming with Arrows</a>.
</p>
<h2> <span class="mw-headline" id="ArrowChoice">13.5 ArrowChoice</span></h2>
<p>Computations built using the <code>Arrow</code> class, like those built using
the <code>Applicative</code> class, are rather inflexible: the structure of the computation
is fixed at the outset, and there is no ability to choose between
alternate execution paths based on intermediate results.
The <code>ArrowChoice</code> class provides exactly such an ability:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Arrow arr <span class="sy0">=&gt;</span> ArrowChoice arr <span class="kw1">where</span>
  left  <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span><span class="kw4">Either</span> b d `arr` <span class="kw4">Either</span> c d<span class="br0">&#41;</span>
  right <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span><span class="kw4">Either</span> d b `arr` <span class="kw4">Either</span> d c<span class="br0">&#41;</span>
  <span class="br0">&#40;</span><span class="sy0">+++</span><span class="br0">&#41;</span> <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>b' `arr` c'<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span><span class="kw4">Either</span> b b' `arr` <span class="kw4">Either</span> c c'<span class="br0">&#41;</span>
  <span class="br0">&#40;</span><span class="sy0">|||</span><span class="br0">&#41;</span> <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` d<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>c `arr` d<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span><span class="kw4">Either</span> b c `arr` d<span class="br0">&#41;</span></pre></div></div>
<p>A comparison of <code>ArrowChoice</code> to <code>Arrow</code> will reveal a striking
parallel between <code>left</code>, <code>right</code>, <code>(+++)</code>, <code>(|||)</code> and <code>first</code>,
<code>second</code>, <code>(***)</code>, <code>(&amp;&amp;&amp;)</code>, respectively.  Indeed, they are dual:
<code>first</code>, <code>second</code>, <code>(***)</code>, and <code>(&amp;&amp;&amp;)</code> all operate on product types
(tuples), and <code>left</code>, <code>right</code>, <code>(+++)</code>, and <code>(|||)</code> are the
corresponding operations on sum types.  In general, these operations
create arrows whose inputs are tagged with <code>Left</code> or <code>Right</code>, and can
choose how to act based on these tags.
</p>
<ul><li> If <code>g</code> is an arrow from <code>b</code> to <code>c</code>, then <code>left g</code> is an arrow from <code>Either b d</code> to <code>Either c d</code>.  On inputs tagged with <code>Left</code>, the <code>left g</code> arrow has the behavior of <code>g</code>; on inputs tagged with <code>Right</code>, it behaves as the identity.
</li></ul>
<ul><li> The <code>right</code> function, of course, is the mirror image of <code>left</code>. The arrow  <code>right g</code> has the behavior of <code>g</code> on inputs tagged with <code>Right</code>.
</li></ul>
<ul><li> The <code>(+++)</code> operator performs “multiplexing”: <code>g +++ h</code> behaves as <code>g</code> on inputs tagged with <code>Left</code>, and as <code>h</code> on inputs tagged with <code>Right</code>.  The tags are preserved.  The <code>(+++)</code> operator is the <i>sum</i> (hence <code>+</code>) of two arrows, just as <code>(***)</code> is the product.
</li></ul>
<ul><li> The <code>(|||)</code> operator is “merge” or “fanin”: the arrow <code>g ||| h</code> behaves as <code>g</code> on inputs tagged with <code>Left</code>, and <code>h</code> on inputs tagged with <code>Right</code>, but the tags are discarded (hence, <code>g</code> and <code>h</code> must have the same output type).  The mnemonic is that <code>g ||| h</code> performs either <code>g</code> <i>or</i> <code>h</code> on its input.
</li></ul>
<p>The <code>ArrowChoice</code> class allows computations to choose among a finite number of execution paths, based on intermediate results.  The possible
execution paths must be known in advance, and explicitly assembled with <code>(+++)</code> or <code>(|||)</code>.  However, sometimes more flexibility is
needed: we would like to be able to <i>compute</i> an arrow from intermediate results, and use this computed arrow to continue the computation.  This is the power given to us by <code>ArrowApply</code>.
</p>
<h2> <span class="mw-headline" id="ArrowApply">13.6 ArrowApply</span></h2>
<p>The <code>ArrowApply</code> type class is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Arrow arr <span class="sy0">=&gt;</span> ArrowApply arr <span class="kw1">where</span>
  app <span class="sy0">::</span> <span class="br0">&#40;</span>b `arr` c<span class="sy0">,</span> b<span class="br0">&#41;</span> `arr` c</pre></div></div>
<p>If we have computed an arrow as the output of some previous
computation, then <code>app</code> allows us to apply that arrow to an input,
producing its output as the output of <code>app</code>.  As an exercise, the
reader may wish to use <code>app</code> to implement an alternative “curried”
version, <code>app2&#160;:: b `arr` ((b `arr` c) `arr` c)</code>.
</p><p>This notion of being able to <i>compute</i> a new computation
may sound familiar:
this is exactly what the monadic bind operator <code>(&gt;&gt;=)</code> does.  It
should not particularly come as a surprise that <code>ArrowApply</code> and
<code>Monad</code> are exactly equivalent in expressive power.  In particular,
<code>Kleisli m</code> can be made an instance of <code>ArrowApply</code>, and any instance
of <code>ArrowApply</code> can be made a <code>Monad</code> (via the <code>newtype</code> wrapper
<code>ArrowMonad</code>).  As an exercise, the reader may wish to try
implementing these instances:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">instance</span> <span class="kw4">Monad</span> m <span class="sy0">=&gt;</span> ArrowApply <span class="br0">&#40;</span>Kleisli m<span class="br0">&#41;</span> <span class="kw1">where</span>
  app <span class="sy0">=</span>    <span class="co1">-- exercise</span>
&#160;
<span class="kw1">newtype</span> ArrowApply a <span class="sy0">=&gt;</span> ArrowMonad a b <span class="sy0">=</span> ArrowMonad <span class="br0">&#40;</span>a <span class="br0">&#40;</span><span class="br0">&#41;</span> b<span class="br0">&#41;</span>
&#160;
<span class="kw1">instance</span> ArrowApply a <span class="sy0">=&gt;</span> <span class="kw4">Monad</span> <span class="br0">&#40;</span>ArrowMonad a<span class="br0">&#41;</span> <span class="kw1">where</span>
  <span class="kw3">return</span>               <span class="sy0">=</span>    <span class="co1">-- exercise</span>
  <span class="br0">&#40;</span>ArrowMonad a<span class="br0">&#41;</span> <span class="sy0">&gt;&gt;=</span> k <span class="sy0">=</span>    <span class="co1">-- exercise</span></pre></div></div>
<h2> <span class="mw-headline" id="ArrowLoop">13.7 ArrowLoop</span></h2>
<p>The <code>ArrowLoop</code> type class is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> Arrow a <span class="sy0">=&gt;</span> ArrowLoop a <span class="kw1">where</span>
  loop <span class="sy0">::</span> a <span class="br0">&#40;</span>b<span class="sy0">,</span> d<span class="br0">&#41;</span> <span class="br0">&#40;</span>c<span class="sy0">,</span> d<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> a b c
&#160;
trace <span class="sy0">::</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>b<span class="sy0">,</span>d<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>c<span class="sy0">,</span>d<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">-&gt;</span> b <span class="sy0">-&gt;</span> c
trace f b <span class="sy0">=</span> <span class="kw1">let</span> <span class="br0">&#40;</span>c<span class="sy0">,</span>d<span class="br0">&#41;</span> <span class="sy0">=</span> f <span class="br0">&#40;</span>b<span class="sy0">,</span>d<span class="br0">&#41;</span> <span class="kw1">in</span> c</pre></div></div>
<p>It describes arrows that can use recursion to compute results, and is
used to desugar the <code>rec</code> construct in arrow notation (described
below).
</p><p>Taken by itself, the type of the <code>loop</code> method does not seem to tell
us much.  Its intention, however, is a generalization of the <code>trace</code>
function which is also shown.  The <code>d</code> component of the first arrow’s
output is fed back in as its own input.  In other words, the arrow
<code>loop g</code> is obtained by recursively “fixing” the second component of
the input to <code>g</code>.
</p><p>It can be a bit difficult to grok what the <code>trace</code> function is doing.
How can <code>d</code> appear on the left and right sides of the <code>let</code>?  Well,
this is Haskell’s laziness at work.  There is not space here for a
full explanation; the interested reader is encouraged to study the
standard <code>fix</code> function, and to read <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/fop.html">Paterson’s arrow tutorial</a>.
</p>
<h2> <span class="mw-headline" id="Arrow_notation">13.8 Arrow notation</span></h2>
<p>Programming directly with the arrow combinators can be painful,
especially when writing complex computations which need to retain
simultaneous reference to a number of intermediate results. With
nothing but the arrow combinators, such intermediate results must be
kept in nested tuples, and it is up to the programmer to remember
which intermediate results are in which components, and to swap,
reassociate, and generally mangle tuples as necessary.  This problem
is solved by the special arrow notation supported by GHC, similar to
<code>do</code> notation for monads, that allows names to be assigned to
intermediate results while building up arrow computations.  An example
arrow implemented using arrow notation, taken from
Paterson, is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> ArrowLoop arr <span class="sy0">=&gt;</span> ArrowCircuit arr <span class="kw1">where</span>
  delay <span class="sy0">::</span> b <span class="sy0">-&gt;</span> <span class="br0">&#40;</span>b `arr` b<span class="br0">&#41;</span>
&#160;
counter <span class="sy0">::</span> ArrowCircuit arr <span class="sy0">=&gt;</span> <span class="kw4">Bool</span> `arr` <span class="kw4">Int</span>
counter <span class="sy0">=</span> proc reset <span class="sy0">-&gt;</span> <span class="kw1">do</span>
            rec output <span class="sy0">&lt;-</span> idA     <span class="sy0">-&lt;</span> <span class="kw1">if</span> reset <span class="kw1">then</span> 0 <span class="kw1">else</span> next
                next   <span class="sy0">&lt;-</span> delay <span class="nu0">0</span> <span class="sy0">-&lt;</span> output <span class="sy0">+</span> <span class="nu0">1</span>
            idA <span class="sy0">-&lt;</span> output</pre></div></div>
<p>This arrow is intended to
represent a recursively defined counter circuit with a reset line.
</p><p>There is not space here for a full explanation of arrow notation; the
interested reader should consult
<a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/notation.html">Paterson’s paper introducing the notation</a>, or his later <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/fop.html">tutorial which presents a simplified version</a>.
</p>
<h2> <span class="mw-headline" id="Further_reading_10">13.9 Further reading</span></h2>
<p>An excellent starting place for the student of arrows is the <a rel="nofollow" class="external text" href="http://www.haskell.org/arrows/">arrows web page</a>, which contains an
introduction and many references. Some key papers on arrows include
Hughes’s original paper introducing arrows, <a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016/S0167-6423(99)00023-4">Generalising monads to arrows</a>, and <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/notation.html">Paterson’s paper on arrow notation</a>.
</p><p>Both Hughes and Paterson later wrote accessible tutorials intended for a broader
audience: <a rel="nofollow" class="external text" href="http://www.soi.city.ac.uk/~ross/papers/fop.html">Paterson: Programming with Arrows</a> and <a rel="nofollow" class="external text" href="http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf">Hughes: Programming with Arrows</a>.
</p><p>Although Hughes’s goal in defining the <code>Arrow</code> class was to
generalize <code>Monad</code>s, and it has been said that <code>Arrow</code> lies “between
<code>Applicative</code> and <code>Monad</code>” in power, they are not directly
comparable.  The precise relationship remained in some confusion until
<a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf">analyzed by Lindley, Wadler, and Yallop</a>, who
also invented a new calculus of arrows, based on the lambda calculus,
which considerably simplifies the presentation of the arrow laws
(see <a rel="nofollow" class="external text" href="http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf">The arrow calculus</a>).  There is also a precise technical sense in which <a rel="nofollow" class="external text" href="http://just-bottom.blogspot.de/2010/04/programming-with-effects-story-so-far.html"><code>Arrow</code> can be seen as the intersection of <code>Applicative</code> and <code>Category</code></a>.
</p><p>Some examples of <code>Arrow</code>s include <a rel="nofollow" class="external text" href="http://www.haskell.org/yampa/">Yampa</a>, the
<a rel="nofollow" class="external text" href="http://www.fh-wedel.de/~si/HXmlToolbox/">Haskell XML Toolkit</a>, and the functional GUI library <a href="/haskellwiki/Grapefruit" title="Grapefruit">Grapefruit</a>.
</p><p>Some extensions to arrows have been explored; for example, the
<a rel="nofollow" class="external text" href="http://www.cs.ru.nl/A.vanWeelden/bi-arrows/"><code>BiArrow</code>s of Alimarine et al.</a>, for two-way instead of one-way
computation.
</p><p>The Haskell wiki has <a href="/haskellwiki/index.php?title=Research_papers/Monads_and_Arrows&amp;action=edit&amp;redlink=1" class="new" title="Research papers/Monads and Arrows (page does not exist)">links to many additional research papers relating to <code>Arrow</code>s</a>.
</p>
<h1> <span class="mw-headline" id="Comonad">14 Comonad</span></h1>
<p>The final type class we will examine is <code>Comonad</code>. The <code>Comonad</code> class
is the categorical dual of <code>Monad</code>; that is, <code>Comonad</code> is like <code>Monad</code>
but with all the function arrows flipped. It is not actually in the
standard Haskell libraries, but it has seen some interesting uses
recently, so we include it here for completeness.
</p>
<h2> <span class="mw-headline" id="Definition_9">14.1 Definition</span></h2>
<p>The <code>Comonad</code> type class, defined in the <code>Control.Comonad</code> module of
the <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/comonad">comonad library</a>, is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="kw1">class</span> <span class="kw4">Functor</span> w <span class="sy0">=&gt;</span> Comonad w <span class="kw1">where</span>
  extract <span class="sy0">::</span> w a <span class="sy0">-&gt;</span> a
&#160;
  duplicate <span class="sy0">::</span> w a <span class="sy0">-&gt;</span> w <span class="br0">&#40;</span>w a<span class="br0">&#41;</span>
  duplicate <span class="sy0">=</span> extend <span class="kw3">id</span>
&#160;
  extend <span class="sy0">::</span> <span class="br0">&#40;</span>w a <span class="sy0">-&gt;</span> b<span class="br0">&#41;</span> <span class="sy0">-&gt;</span> w a <span class="sy0">-&gt;</span> w b
  extend f <span class="sy0">=</span> <span class="kw3">fmap</span> f <span class="sy0">.</span> duplicate</pre></div></div>
<p>As you can see, <code>extract</code> is the dual of <code>return</code>, <code>duplicate</code> is the dual of <code>join</code>, and <code>extend</code> is the dual of <code>(=&lt;&lt;)</code>.  The definition of <code>Comonad</code> is a bit redundant, giving the programmer the choice on whether extend or duplicate are implemented; the other operation then has a default implementation.
</p><p>A prototypical example of a <code>Comonad</code> instance is:
</p>
<div dir="ltr" class="mw-geshi mw-content-ltr"><div class="haskell source-haskell" style="font-family:monospace;"><pre class="de1"><span class="co1">-- Infinite lazy streams</span>
<span class="kw1">data</span> Stream a <span class="sy0">=</span> Cons a <span class="br0">&#40;</span>Stream a<span class="br0">&#41;</span>
&#160;
<span class="co1">-- 'duplicate' is like the list function 'tails'</span>
<span class="co1">-- 'extend' computes a new Stream from an old, where the element</span>
<span class="co1">--   at position n is computed as a function of everything from</span>
<span class="co1">--   position n onwards in the old Stream</span>
<span class="kw1">instance</span> Comonad Stream <span class="kw1">where</span>
  extract <span class="br0">&#40;</span>Cons x <span class="sy0">_</span><span class="br0">&#41;</span> <span class="sy0">=</span> x
  duplicate s<span class="sy0">@</span><span class="br0">&#40;</span>Cons x xs<span class="br0">&#41;</span> <span class="sy0">=</span> Cons s <span class="br0">&#40;</span>duplicate xs<span class="br0">&#41;</span>
  extend g s<span class="sy0">@</span><span class="br0">&#40;</span>Cons x xs<span class="br0">&#41;</span>  <span class="sy0">=</span> Cons <span class="br0">&#40;</span>g s<span class="br0">&#41;</span> <span class="br0">&#40;</span>extend g xs<span class="br0">&#41;</span>
                       <span class="co1">-- = fmap g (duplicate s)</span></pre></div></div>
<h2> <span class="mw-headline" id="Further_reading_11">14.2 Further reading</span></h2>
<p>Dan Piponi explains in a blog post what <a rel="nofollow" class="external text" href="http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html">cellular automata have to do with comonads</a>.  In another blog post, Conal Elliott has examined <a rel="nofollow" class="external text" href="http://conal.net/blog/posts/functional-interactive-behavior/">a comonadic formulation of functional reactive programming</a>.  Sterling Clover’s blog post <a rel="nofollow" class="external text" href="http://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/">Comonads in everyday life</a> explains the relationship between comonads and zippers, and how comonads can be used to design a menu system for a web site.
</p><p>Uustalu and Vene have a number of papers exploring ideas related to comonads and functional programming:
</p>
<ul><li> <a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016/j.entcs.2008.05.029">Comonadic Notions of Computation</a>
</li><li> <a rel="nofollow" class="external text" href="http://www.ioc.ee/~tarmo/papers/sfp01-book.pdf">The dual of substitution is redecoration</a> (Also available as <a rel="nofollow" class="external text" href="http://www.cs.ut.ee/~varmo/papers/sfp01-book.ps.gz">ps.gz</a>.)
</li><li> <a rel="nofollow" class="external text" href="http://dx.doi.org/10.1016/j.ic.2005.08.005">Recursive coalgebras from comonads</a>
</li><li> <a rel="nofollow" class="external text" href="http://www.fing.edu.uy/~pardo/papers/njc01.ps.gz">Recursion schemes from comonads</a>
</li><li> <a rel="nofollow" class="external text" href="http://cs.ioc.ee/~tarmo/papers/essence.pdf">The Essence of Dataflow Programming</a>.
</li></ul>
<p>Gabriel Gonzalez's <a rel="nofollow" class="external text" href="http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html">Comonads are objects</a> points out similarities between comonads and object-oriented programming.
</p><p>The <a rel="nofollow" class="external text" href="http://hackage.haskell.org/package/comonad-transformers">comonad-transformers</a> package contains comonad transformers.
</p>
<h1> <span class="mw-headline" id="Acknowledgements">15 Acknowledgements</span></h1>
<p>A special thanks to all of those who taught me about standard Haskell
type classes and helped me develop good intuition for them,
particularly Jules Bean (quicksilver), Derek Elkins (ddarius), Conal
Elliott (conal), Cale Gibbard (Cale), David House, Dan Piponi
(sigfpe), and Kevin Reid (kpreid).
</p><p>I also thank the many people who provided a mountain of helpful
feedback and suggestions on a first draft of the Typeclassopedia: David Amos,
Kevin Ballard, Reid Barton, Doug Beardsley, Joachim Breitner, Andrew
Cave, David Christiansen, Gregory Collins, Mark Jason Dominus, Conal
Elliott, Yitz Gale, George Giorgidze, Steven Grady, Travis Hartwell,
Steve Hicks, Philip Hölzenspies, Edward Kmett, Eric Kow, Serge Le
Huitouze, Felipe Lessa, Stefan Ljungstrand, Eric Macaulay, Rob MacAulay, Simon Meier,
Eric Mertens, Tim Newsham, Russell O’Connor, Conrad Parker, Walt
Rorie-Baety, Colin Ross, Tom Schrijvers, Aditya Siram, C. Smith,
Martijn van Steenbergen, Joe Thornber, Jared Updike, Rob Vollmert,
Andrew Wagner, Louis Wasserman, and Ashley Yakeley, as well as a few
only known to me by their IRC nicks: b_jonas, maltem, tehgeekmeister,
and ziman.  I have undoubtedly omitted a few inadvertently, which in
no way diminishes my gratitude.
</p><p>Finally, I would like to thank Wouter Swierstra for his fantastic work
editing the Monad.Reader, and my wife Joyia for her patience during
the process of writing the Typeclassopedia.
</p>
<h1> <span class="mw-headline" id="About_the_author">16 About the author</span></h1>
<p>Brent Yorgey (<a rel="nofollow" class="external text" href="http://byorgey.wordpress.com/">blog</a>, <a rel="nofollow" class="external text" href="http://www.cis.upenn.edu/~byorgey/">homepage</a>) is (as of November 2011) a fourth-year Ph.D. student in the <a rel="nofollow" class="external text" href="http://www.cis.upenn.edu/~plclub/">programming languages group</a> at the <a rel="nofollow" class="external text" href="http://www.upenn.edu">University of Pennsylvania</a>.  He enjoys teaching, creating EDSLs, playing Bach fugues, musing upon category theory, and cooking tasty lambda-treats for the denizens of #haskell.
</p>
<h1> <span class="mw-headline" id="Colophon">17 Colophon</span></h1>
<p>The Typeclassopedia was written by Brent Yorgey and initially published in March 2009. Painstakingly converted to wiki syntax by <a href="/haskellwiki/User:Geheimdienst" title="User:Geheimdienst">User:Geheimdienst</a> in November 2011, after asking Brent’s permission.
</p><p>If something like this TeX to wiki syntax conversion ever needs to be done again, here are some vim commands that helped:
</p>
<ul><li> %s/\\section{\([^}]*\)}/=\1=/gc
</li><li> %s/\\subsection{\([^}]*\)}/==\1==/gc
</li><li> %s/^ *\\item /\r* /gc
</li><li> %s/---/—/gc
</li><li> %s/\$\([^$]*\)\$/&lt;math&gt;\1\\ &lt;\/math&gt;/gc <i>Appending “\ ” forces images to be rendered. Otherwise, Mediawiki would go back and forth between one font for short &lt;math&gt; tags, and another more Tex-like font for longer tags (containing more than a few characters)""</i>
</li><li> %s/|\([^|]*\)|/&lt;code&gt;\1&lt;\/code&gt;/gc
</li><li> %s/\\dots/.../gc
</li><li> %s/^\\label{.*$//gc
</li><li> %s/\\emph{\([^}]*\)}/''\1''/gc
</li><li> %s/\\term{\([^}]*\)}/''\1''/gc
</li></ul>
<p>The biggest issue was taking the academic-paper-style citations and turning them into hyperlinks with an appropriate title and an appropriate target. In most cases there was an obvious thing to do (e.g. online PDFs of the cited papers or CiteSeer entries). Sometimes, however, it’s less clear and you might want to check the
<a href="/wikiupload/e/e9/Typeclassopedia.pdf" class="internal" title="Typeclassopedia.pdf">original Typeclassopedia PDF</a>
with the
<a rel="nofollow" class="external text" href="http://code.haskell.org/~byorgey/TMR/Issue13/typeclassopedia.bib">original bibliography file</a>.
</p><p>To get all the citations into the main text, I first tried processing the source with TeX or Lyx. This didn’t work due to missing unfindable packages, syntax errors, and my general ineptitude with Tex.
</p><p>I then went for the next best solution, which seemed to be extracting all instances of “\cite{something}” from the source and <i>in that order</i> pulling the referenced entries from the .bib file. This way you can go through the source file and sorted-references file in parallel, copying over what you need, without searching back and forth in the .bib file. I used:
</p>
<ul><li> egrep -o &quot;\cite\{[^\}]*\}&quot; ~/typeclassopedia.lhs | cut -c 6- | tr &quot;,&quot; &quot;\n&quot; | tr -d &quot;}&quot; &gt; /tmp/citations
</li><li> for i in $(cat /tmp/citations); do  grep -A99 &quot;$i&quot; ~/typeclassopedia.bib|egrep -B99 '^\}$' -m1 ; done &gt; ~/typeclasso-refs-sorted
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 1777/1000000
Post‐expand include size: 20628/2097152 bytes
Template argument size: 11652/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:5000-0!1!0!1!en!2!* and timestamp 20140917061041 -->
</div><div class="printfooter">
Retrieved from "<a href="http://www.haskell.org/haskellwiki/index.php?title=Typeclassopedia&amp;oldid=58733">http://www.haskell.org/haskellwiki/index.php?title=Typeclassopedia&amp;oldid=58733</a>"</div>
			<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/haskellwiki/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="/haskellwiki/Category:Applicative_Functor" title="Category:Applicative Functor">Applicative Functor</a></li><li><a href="/haskellwiki/Category:Arrow" title="Category:Arrow">Arrow</a></li><li><a href="/haskellwiki/Category:Functor" title="Category:Functor">Functor</a></li><li><a href="/haskellwiki/Category:Monad" title="Category:Monad">Monad</a></li><li><a href="/haskellwiki/Category:Standard_classes" title="Category:Standard classes">Standard classes</a></li><li><a href="/haskellwiki/Category:Standard_libraries" title="Category:Standard libraries">Standard libraries</a></li><li><a href="/haskellwiki/Category:Standard_packages" title="Category:Standard packages">Standard packages</a></li><li><a href="/haskellwiki/Category:Standard_types" title="Category:Standard types">Standard types</a></li></ul></div></div>			<!-- end content -->
						<div class="visualClear"></div>
		</div>
	</div>
		</div></div>
		<div id="column-one">
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class='generated-sidebar portlet' id='p-navigation'>
		<h5>Navigation</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage"><a href="/haskellwiki/Haskell">Haskell</a></li>
				<li id="n-portal"><a href="/haskellwiki/HaskellWiki:Community">Wiki community</a></li>
				<li id="n-recentchanges"><a href="/haskellwiki/Special:RecentChanges">Recent changes</a></li>
				<li id="n-randompage"><a href="/haskellwiki/Special:Random">Random page</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-tb">
		<h5>Toolbox</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/haskellwiki/Special:WhatLinksHere/Typeclassopedia">What links here</a></li>
				<li id="t-recentchangeslinked"><a href="/haskellwiki/Special:RecentChangesLinked/Typeclassopedia">Related changes</a></li>
<li id="t-specialpages"><a href="/haskellwiki/Special:SpecialPages">Special pages</a></li>
				<li id="t-print"><a href="/haskellwiki/index.php?title=Typeclassopedia&amp;printable=yes" rel="alternate">Printable version</a></li>				<li id="t-permalink"><a href="/haskellwiki/index.php?title=Typeclassopedia&amp;oldid=58733">Permanent link</a></li>			</ul>
		</div>
	</div>
		</div><!-- end of the left (by default at least) column -->
			<div class="visualClear"></div>
			<div id="footer">
				<div id="f-poweredbyico"><a href="//www.mediawiki.org/"><img src="/wikistatic/skins//common/images/poweredby_mediawiki_88x31.png" height="31" width="88" alt="Powered by MediaWiki" /></a></div>
			<ul id="f-list">
					<li id="lastmod"> This page was last modified on 3 September 2014, at 03:18.</li>
					<li id="viewcount">This page has been accessed 179,028 times.</li>
					<li id="copyright">Recent content is available under <a href="/haskellwiki/HaskellWiki:Copyrights" title="HaskellWiki:Copyrights">a simple permissive license</a>.</li>
					<li id="privacy"><a href="/haskellwiki/HaskellWiki:Privacy_policy" title="HaskellWiki:Privacy policy">Privacy policy</a></li>
					<li id="about"><a href="/haskellwiki/HaskellWiki:About" title="HaskellWiki:About">About HaskellWiki</a></li>
					<li id="disclaimer"><a href="/haskellwiki/HaskellWiki:General_disclaimer" title="HaskellWiki:General disclaimer">Disclaimers</a></li>
			</ul>
		</div>
</div>
<script>if(window.mw){
mw.loader.load(["mediawiki.user","mediawiki.page.ready"], null, true);
}</script>
<script src="http://www.haskell.org/haskellwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=hawiki&amp;*"></script>
<!-- Served in 0.818 secs. --><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-15375175-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body></html>
